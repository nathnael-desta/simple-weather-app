"use strict";
(self["webpackChunkbasic_template"] = self["webpackChunkbasic_template"] || []).push([["print"],{

/***/ "./node_modules/@openmeteo/sdk/aggregation.js":
/*!****************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/aggregation.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {


// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Aggregation = void 0;
var Aggregation;
(function (Aggregation) {
    Aggregation[Aggregation["none"] = 0] = "none";
    Aggregation[Aggregation["minimum"] = 1] = "minimum";
    Aggregation[Aggregation["maximum"] = 2] = "maximum";
    Aggregation[Aggregation["mean"] = 3] = "mean";
    Aggregation[Aggregation["p10"] = 4] = "p10";
    Aggregation[Aggregation["p25"] = 5] = "p25";
    Aggregation[Aggregation["median"] = 6] = "median";
    Aggregation[Aggregation["p75"] = 7] = "p75";
    Aggregation[Aggregation["p90"] = 8] = "p90";
    Aggregation[Aggregation["dominant"] = 9] = "dominant";
    Aggregation[Aggregation["sum"] = 10] = "sum";
})(Aggregation || (exports.Aggregation = Aggregation = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/model.js":
/*!**********************************************!*\
  !*** ./node_modules/@openmeteo/sdk/model.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {


// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Model = void 0;
var Model;
(function (Model) {
    Model[Model["undefined"] = 0] = "undefined";
    Model[Model["best_match"] = 1] = "best_match";
    Model[Model["gfs_seamless"] = 2] = "gfs_seamless";
    Model[Model["gfs_global"] = 3] = "gfs_global";
    Model[Model["gfs_hrrr"] = 4] = "gfs_hrrr";
    Model[Model["meteofrance_seamless"] = 5] = "meteofrance_seamless";
    Model[Model["meteofrance_arpege_seamless"] = 6] = "meteofrance_arpege_seamless";
    Model[Model["meteofrance_arpege_world"] = 7] = "meteofrance_arpege_world";
    Model[Model["meteofrance_arpege_europe"] = 8] = "meteofrance_arpege_europe";
    Model[Model["meteofrance_arome_seamless"] = 9] = "meteofrance_arome_seamless";
    Model[Model["meteofrance_arome_france"] = 10] = "meteofrance_arome_france";
    Model[Model["meteofrance_arome_france_hd"] = 11] = "meteofrance_arome_france_hd";
    Model[Model["jma_seamless"] = 12] = "jma_seamless";
    Model[Model["jma_msm"] = 13] = "jma_msm";
    Model[Model["jms_gsm"] = 14] = "jms_gsm";
    Model[Model["jma_gsm"] = 15] = "jma_gsm";
    Model[Model["gem_seamless"] = 16] = "gem_seamless";
    Model[Model["gem_global"] = 17] = "gem_global";
    Model[Model["gem_regional"] = 18] = "gem_regional";
    Model[Model["gem_hrdps_continental"] = 19] = "gem_hrdps_continental";
    Model[Model["icon_seamless"] = 20] = "icon_seamless";
    Model[Model["icon_global"] = 21] = "icon_global";
    Model[Model["icon_eu"] = 22] = "icon_eu";
    Model[Model["icon_d2"] = 23] = "icon_d2";
    Model[Model["ecmwf_ifs04"] = 24] = "ecmwf_ifs04";
    Model[Model["metno_nordic"] = 25] = "metno_nordic";
    Model[Model["era5_seamless"] = 26] = "era5_seamless";
    Model[Model["era5"] = 27] = "era5";
    Model[Model["cerra"] = 28] = "cerra";
    Model[Model["era5_land"] = 29] = "era5_land";
    Model[Model["ecmwf_ifs"] = 30] = "ecmwf_ifs";
    Model[Model["gwam"] = 31] = "gwam";
    Model[Model["ewam"] = 32] = "ewam";
    Model[Model["glofas_seamless_v3"] = 33] = "glofas_seamless_v3";
    Model[Model["glofas_forecast_v3"] = 34] = "glofas_forecast_v3";
    Model[Model["glofas_consolidated_v3"] = 35] = "glofas_consolidated_v3";
    Model[Model["glofas_seamless_v4"] = 36] = "glofas_seamless_v4";
    Model[Model["glofas_forecast_v4"] = 37] = "glofas_forecast_v4";
    Model[Model["glofas_consolidated_v4"] = 38] = "glofas_consolidated_v4";
    Model[Model["gfs025"] = 39] = "gfs025";
    Model[Model["gfs05"] = 40] = "gfs05";
    Model[Model["CMCC_CM2_VHR4"] = 41] = "CMCC_CM2_VHR4";
    Model[Model["FGOALS_f3_H_highresSST"] = 42] = "FGOALS_f3_H_highresSST";
    Model[Model["FGOALS_f3_H"] = 43] = "FGOALS_f3_H";
    Model[Model["HiRAM_SIT_HR"] = 44] = "HiRAM_SIT_HR";
    Model[Model["MRI_AGCM3_2_S"] = 45] = "MRI_AGCM3_2_S";
    Model[Model["EC_Earth3P_HR"] = 46] = "EC_Earth3P_HR";
    Model[Model["MPI_ESM1_2_XR"] = 47] = "MPI_ESM1_2_XR";
    Model[Model["NICAM16_8S"] = 48] = "NICAM16_8S";
    Model[Model["cams_europe"] = 49] = "cams_europe";
    Model[Model["cams_global"] = 50] = "cams_global";
    Model[Model["cfsv2"] = 51] = "cfsv2";
    Model[Model["era5_ocean"] = 52] = "era5_ocean";
    Model[Model["cma_grapes_global"] = 53] = "cma_grapes_global";
    Model[Model["bom_access_global"] = 54] = "bom_access_global";
    Model[Model["bom_access_global_ensemble"] = 55] = "bom_access_global_ensemble";
    Model[Model["arpae_cosmo_seamless"] = 56] = "arpae_cosmo_seamless";
    Model[Model["arpae_cosmo_2i"] = 57] = "arpae_cosmo_2i";
    Model[Model["arpae_cosmo_2i_ruc"] = 58] = "arpae_cosmo_2i_ruc";
    Model[Model["arpae_cosmo_5m"] = 59] = "arpae_cosmo_5m";
    Model[Model["ecmwf_ifs025"] = 60] = "ecmwf_ifs025";
})(Model || (exports.Model = Model = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/unit.js":
/*!*********************************************!*\
  !*** ./node_modules/@openmeteo/sdk/unit.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {


// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unit = void 0;
var Unit;
(function (Unit) {
    Unit[Unit["undefined"] = 0] = "undefined";
    Unit[Unit["celsius"] = 1] = "celsius";
    Unit[Unit["centimetre"] = 2] = "centimetre";
    Unit[Unit["cubic_metre_per_cubic_metre"] = 3] = "cubic_metre_per_cubic_metre";
    Unit[Unit["cubic_metre_per_second"] = 4] = "cubic_metre_per_second";
    Unit[Unit["degree_direction"] = 5] = "degree_direction";
    Unit[Unit["dimensionless_integer"] = 6] = "dimensionless_integer";
    Unit[Unit["dimensionless"] = 7] = "dimensionless";
    Unit[Unit["european_air_quality_index"] = 8] = "european_air_quality_index";
    Unit[Unit["fahrenheit"] = 9] = "fahrenheit";
    Unit[Unit["feet"] = 10] = "feet";
    Unit[Unit["fraction"] = 11] = "fraction";
    Unit[Unit["gdd_celsius"] = 12] = "gdd_celsius";
    Unit[Unit["geopotential_metre"] = 13] = "geopotential_metre";
    Unit[Unit["grains_per_cubic_metre"] = 14] = "grains_per_cubic_metre";
    Unit[Unit["gram_per_kilogram"] = 15] = "gram_per_kilogram";
    Unit[Unit["hectopascal"] = 16] = "hectopascal";
    Unit[Unit["hours"] = 17] = "hours";
    Unit[Unit["inch"] = 18] = "inch";
    Unit[Unit["iso8601"] = 19] = "iso8601";
    Unit[Unit["joule_per_kilogram"] = 20] = "joule_per_kilogram";
    Unit[Unit["kelvin"] = 21] = "kelvin";
    Unit[Unit["kilopascal"] = 22] = "kilopascal";
    Unit[Unit["kilogram_per_square_metre"] = 23] = "kilogram_per_square_metre";
    Unit[Unit["kilometres_per_hour"] = 24] = "kilometres_per_hour";
    Unit[Unit["knots"] = 25] = "knots";
    Unit[Unit["megajoule_per_square_metre"] = 26] = "megajoule_per_square_metre";
    Unit[Unit["metre_per_second_not_unit_converted"] = 27] = "metre_per_second_not_unit_converted";
    Unit[Unit["metre_per_second"] = 28] = "metre_per_second";
    Unit[Unit["metre"] = 29] = "metre";
    Unit[Unit["micrograms_per_cubic_metre"] = 30] = "micrograms_per_cubic_metre";
    Unit[Unit["miles_per_hour"] = 31] = "miles_per_hour";
    Unit[Unit["millimetre"] = 32] = "millimetre";
    Unit[Unit["pascal"] = 33] = "pascal";
    Unit[Unit["per_second"] = 34] = "per_second";
    Unit[Unit["percentage"] = 35] = "percentage";
    Unit[Unit["seconds"] = 36] = "seconds";
    Unit[Unit["unix_time"] = 37] = "unix_time";
    Unit[Unit["us_air_quality_index"] = 38] = "us_air_quality_index";
    Unit[Unit["watt_per_square_metre"] = 39] = "watt_per_square_metre";
    Unit[Unit["wmo_code"] = 40] = "wmo_code";
})(Unit || (exports.Unit = Unit = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/variable-with-values.js":
/*!*************************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/variable-with-values.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// automatically generated by the FlatBuffers compiler, do not modify
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VariableWithValues = void 0;
const flatbuffers = __importStar(__webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js"));
const aggregation_js_1 = __webpack_require__(/*! ./aggregation.js */ "./node_modules/@openmeteo/sdk/aggregation.js");
const unit_js_1 = __webpack_require__(/*! ./unit.js */ "./node_modules/@openmeteo/sdk/unit.js");
const variable_js_1 = __webpack_require__(/*! ./variable.js */ "./node_modules/@openmeteo/sdk/variable.js");
class VariableWithValues {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVariableWithValues(bb, obj) {
        return (obj || new VariableWithValues()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVariableWithValues(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new VariableWithValues()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    variable() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : variable_js_1.Variable.undefined;
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : unit_js_1.Unit.undefined;
    }
    value() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    values(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    valuesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    valuesArray() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    valuesInt64(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    valuesInt64Length() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    altitude() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    aggregation() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : aggregation_js_1.Aggregation.none;
    }
    pressureLevel() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    depth() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    depthTo() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    ensembleMember() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    previousDay() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
}
exports.VariableWithValues = VariableWithValues;


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/variable.js":
/*!*************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/variable.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Variable = void 0;
var Variable;
(function (Variable) {
    Variable[Variable["undefined"] = 0] = "undefined";
    Variable[Variable["apparent_temperature"] = 1] = "apparent_temperature";
    Variable[Variable["cape"] = 2] = "cape";
    Variable[Variable["cloud_cover"] = 3] = "cloud_cover";
    Variable[Variable["cloud_cover_high"] = 4] = "cloud_cover_high";
    Variable[Variable["cloud_cover_low"] = 5] = "cloud_cover_low";
    Variable[Variable["cloud_cover_mid"] = 6] = "cloud_cover_mid";
    Variable[Variable["daylight_duration"] = 7] = "daylight_duration";
    Variable[Variable["dew_point"] = 8] = "dew_point";
    Variable[Variable["diffuse_radiation"] = 9] = "diffuse_radiation";
    Variable[Variable["diffuse_radiation_instant"] = 10] = "diffuse_radiation_instant";
    Variable[Variable["direct_normal_irradiance"] = 11] = "direct_normal_irradiance";
    Variable[Variable["direct_normal_irradiance_instant"] = 12] = "direct_normal_irradiance_instant";
    Variable[Variable["direct_radiation"] = 13] = "direct_radiation";
    Variable[Variable["direct_radiation_instant"] = 14] = "direct_radiation_instant";
    Variable[Variable["et0_fao_evapotranspiration"] = 15] = "et0_fao_evapotranspiration";
    Variable[Variable["evapotranspiration"] = 16] = "evapotranspiration";
    Variable[Variable["freezing_level_height"] = 17] = "freezing_level_height";
    Variable[Variable["growing_degree_days"] = 18] = "growing_degree_days";
    Variable[Variable["is_day"] = 19] = "is_day";
    Variable[Variable["latent_heat_flux"] = 20] = "latent_heat_flux";
    Variable[Variable["leaf_wetness_probability"] = 21] = "leaf_wetness_probability";
    Variable[Variable["lifted_index"] = 22] = "lifted_index";
    Variable[Variable["lightning_potential"] = 23] = "lightning_potential";
    Variable[Variable["precipitation"] = 24] = "precipitation";
    Variable[Variable["precipitation_hours"] = 25] = "precipitation_hours";
    Variable[Variable["precipitation_probability"] = 26] = "precipitation_probability";
    Variable[Variable["pressure_msl"] = 27] = "pressure_msl";
    Variable[Variable["rain"] = 28] = "rain";
    Variable[Variable["relative_humidity"] = 29] = "relative_humidity";
    Variable[Variable["runoff"] = 30] = "runoff";
    Variable[Variable["sensible_heat_flux"] = 31] = "sensible_heat_flux";
    Variable[Variable["shortwave_radiation"] = 32] = "shortwave_radiation";
    Variable[Variable["shortwave_radiation_instant"] = 33] = "shortwave_radiation_instant";
    Variable[Variable["showers"] = 34] = "showers";
    Variable[Variable["snow_depth"] = 35] = "snow_depth";
    Variable[Variable["snow_height"] = 36] = "snow_height";
    Variable[Variable["snowfall"] = 37] = "snowfall";
    Variable[Variable["snowfall_height"] = 38] = "snowfall_height";
    Variable[Variable["snowfall_water_equivalent"] = 39] = "snowfall_water_equivalent";
    Variable[Variable["sunrise"] = 40] = "sunrise";
    Variable[Variable["sunset"] = 41] = "sunset";
    Variable[Variable["soil_moisture"] = 42] = "soil_moisture";
    Variable[Variable["soil_moisture_index"] = 43] = "soil_moisture_index";
    Variable[Variable["soil_temperature"] = 44] = "soil_temperature";
    Variable[Variable["surface_pressure"] = 45] = "surface_pressure";
    Variable[Variable["surface_temperature"] = 46] = "surface_temperature";
    Variable[Variable["temperature"] = 47] = "temperature";
    Variable[Variable["terrestrial_radiation"] = 48] = "terrestrial_radiation";
    Variable[Variable["terrestrial_radiation_instant"] = 49] = "terrestrial_radiation_instant";
    Variable[Variable["total_column_integrated_water_vapour"] = 50] = "total_column_integrated_water_vapour";
    Variable[Variable["updraft"] = 51] = "updraft";
    Variable[Variable["uv_index"] = 52] = "uv_index";
    Variable[Variable["uv_index_clear_sky"] = 53] = "uv_index_clear_sky";
    Variable[Variable["vapour_pressure_deficit"] = 54] = "vapour_pressure_deficit";
    Variable[Variable["visibility"] = 55] = "visibility";
    Variable[Variable["weather_code"] = 56] = "weather_code";
    Variable[Variable["wind_direction"] = 57] = "wind_direction";
    Variable[Variable["wind_gusts"] = 58] = "wind_gusts";
    Variable[Variable["wind_speed"] = 59] = "wind_speed";
    Variable[Variable["vertical_velocity"] = 60] = "vertical_velocity";
    Variable[Variable["geopotential_height"] = 61] = "geopotential_height";
    Variable[Variable["wet_bulb_temperature"] = 62] = "wet_bulb_temperature";
    Variable[Variable["river_discharge"] = 63] = "river_discharge";
    Variable[Variable["wave_height"] = 64] = "wave_height";
    Variable[Variable["wave_period"] = 65] = "wave_period";
    Variable[Variable["wave_direction"] = 66] = "wave_direction";
    Variable[Variable["wind_wave_height"] = 67] = "wind_wave_height";
    Variable[Variable["wind_wave_period"] = 68] = "wind_wave_period";
    Variable[Variable["wind_wave_peak_period"] = 69] = "wind_wave_peak_period";
    Variable[Variable["wind_wave_direction"] = 70] = "wind_wave_direction";
    Variable[Variable["swell_wave_height"] = 71] = "swell_wave_height";
    Variable[Variable["swell_wave_period"] = 72] = "swell_wave_period";
    Variable[Variable["swell_wave_peak_period"] = 73] = "swell_wave_peak_period";
    Variable[Variable["swell_wave_direction"] = 74] = "swell_wave_direction";
    Variable[Variable["pm10"] = 75] = "pm10";
    Variable[Variable["pm2p5"] = 76] = "pm2p5";
    Variable[Variable["dust"] = 77] = "dust";
    Variable[Variable["aerosol_optical_depth"] = 78] = "aerosol_optical_depth";
    Variable[Variable["carbon_monoxide"] = 79] = "carbon_monoxide";
    Variable[Variable["nitrogen_dioxide"] = 80] = "nitrogen_dioxide";
    Variable[Variable["ammonia"] = 81] = "ammonia";
    Variable[Variable["ozone"] = 82] = "ozone";
    Variable[Variable["sulphur_dioxide"] = 83] = "sulphur_dioxide";
    Variable[Variable["alder_pollen"] = 84] = "alder_pollen";
    Variable[Variable["birch_pollen"] = 85] = "birch_pollen";
    Variable[Variable["grass_pollen"] = 86] = "grass_pollen";
    Variable[Variable["mugwort_pollen"] = 87] = "mugwort_pollen";
    Variable[Variable["olive_pollen"] = 88] = "olive_pollen";
    Variable[Variable["ragweed_pollen"] = 89] = "ragweed_pollen";
    Variable[Variable["european_aqi"] = 90] = "european_aqi";
    Variable[Variable["european_aqi_pm2p5"] = 91] = "european_aqi_pm2p5";
    Variable[Variable["european_aqi_pm10"] = 92] = "european_aqi_pm10";
    Variable[Variable["european_aqi_nitrogen_dioxide"] = 93] = "european_aqi_nitrogen_dioxide";
    Variable[Variable["european_aqi_ozone"] = 94] = "european_aqi_ozone";
    Variable[Variable["european_aqi_sulphur_dioxide"] = 95] = "european_aqi_sulphur_dioxide";
    Variable[Variable["us_aqi"] = 96] = "us_aqi";
    Variable[Variable["us_aqi_pm2p5"] = 97] = "us_aqi_pm2p5";
    Variable[Variable["us_aqi_pm10"] = 98] = "us_aqi_pm10";
    Variable[Variable["us_aqi_nitrogen_dioxide"] = 99] = "us_aqi_nitrogen_dioxide";
    Variable[Variable["us_aqi_ozone"] = 100] = "us_aqi_ozone";
    Variable[Variable["us_aqi_sulphur_dioxide"] = 101] = "us_aqi_sulphur_dioxide";
    Variable[Variable["us_aqi_carbon_monoxide"] = 102] = "us_aqi_carbon_monoxide";
    Variable[Variable["sunshine_duration"] = 103] = "sunshine_duration";
    Variable[Variable["convective_inhibition"] = 104] = "convective_inhibition";
    Variable[Variable["shortwave_radiation_clear_sky"] = 105] = "shortwave_radiation_clear_sky";
    Variable[Variable["global_tilted_irradiance"] = 106] = "global_tilted_irradiance";
    Variable[Variable["global_tilted_irradiance_instant"] = 107] = "global_tilted_irradiance_instant";
})(Variable || (exports.Variable = Variable = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/variables-with-time.js":
/*!************************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/variables-with-time.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// automatically generated by the FlatBuffers compiler, do not modify
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VariablesWithTime = void 0;
const flatbuffers = __importStar(__webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js"));
const variable_with_values_js_1 = __webpack_require__(/*! ./variable-with-values.js */ "./node_modules/@openmeteo/sdk/variable-with-values.js");
class VariablesWithTime {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVariablesWithTime(bb, obj) {
        return (obj || new VariablesWithTime()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVariablesWithTime(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new VariablesWithTime()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    time() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    timeEnd() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    interval() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    variables(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new variable_with_values_js_1.VariableWithValues()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    variablesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
}
exports.VariablesWithTime = VariablesWithTime;


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/weather-api-response.js":
/*!*************************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/weather-api-response.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// automatically generated by the FlatBuffers compiler, do not modify
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeatherApiResponse = void 0;
const flatbuffers = __importStar(__webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js"));
const model_js_1 = __webpack_require__(/*! ./model.js */ "./node_modules/@openmeteo/sdk/model.js");
const variables_with_time_js_1 = __webpack_require__(/*! ./variables-with-time.js */ "./node_modules/@openmeteo/sdk/variables-with-time.js");
class WeatherApiResponse {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsWeatherApiResponse(bb, obj) {
        return (obj || new WeatherApiResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsWeatherApiResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new WeatherApiResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    latitude() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    longitude() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    elevation() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    generationTimeMilliseconds() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    locationId() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    model() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : model_js_1.Model.undefined;
    }
    utcOffsetSeconds() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    timezone(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    timezoneAbbreviation(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    current(obj) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    daily(obj) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    hourly(obj) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    minutely15(obj) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    sixHourly(obj) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
}
exports.WeatherApiResponse = WeatherApiResponse;


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/builder.js":
/*!*************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/builder.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* binding */ Builder)
/* harmony export */ });
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-buffer.js */ "./node_modules/flatbuffers/mjs/byte-buffer.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./node_modules/flatbuffers/mjs/constants.js");


class Builder {
    /**
     * Create a FlatBufferBuilder.
     */
    constructor(opt_initial_size) {
        /** Minimum alignment encountered so far. */
        this.minalign = 1;
        /** The vtable for the current table. */
        this.vtable = null;
        /** The amount of fields we're actually using. */
        this.vtable_in_use = 0;
        /** Whether we are currently serializing a table. */
        this.isNested = false;
        /** Starting offset of the current struct/table. */
        this.object_start = 0;
        /** List of offsets of all vtables. */
        this.vtables = [];
        /** For the current vector being built. */
        this.vector_num_elems = 0;
        /** False omits default values from the serialized data */
        this.force_defaults = false;
        this.string_maps = null;
        this.text_encoder = new TextEncoder();
        let initial_size;
        if (!opt_initial_size) {
            initial_size = 1024;
        }
        else {
            initial_size = opt_initial_size;
        }
        /**
         * @type {ByteBuffer}
         * @private
         */
        this.bb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(initial_size);
        this.space = initial_size;
    }
    clear() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
    }
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */
    forceDefaults(forceDefaults) {
        this.force_defaults = forceDefaults;
    }
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */
    dataBuffer() {
        return this.bb;
    }
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */
    asUint8Array() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */
    prep(size, additional_bytes) {
        // Track the biggest thing we've ever aligned to.
        if (size > this.minalign) {
            this.minalign = size;
        }
        // Find the amount of alignment needed such that `size` is properly
        // aligned after `additional_bytes`
        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);
        // Reallocate the buffer if needed.
        while (this.space < align_size + size + additional_bytes) {
            const old_buf_size = this.bb.capacity();
            this.bb = Builder.growByteBuffer(this.bb);
            this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
    }
    pad(byte_size) {
        for (let i = 0; i < byte_size; i++) {
            this.bb.writeInt8(--this.space, 0);
        }
    }
    writeInt8(value) {
        this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
        this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
        this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
        this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
        this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
        this.bb.writeFloat64(this.space -= 8, value);
    }
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the buffer.
     */
    addInt8(value) {
        this.prep(1, 0);
        this.writeInt8(value);
    }
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the buffer.
     */
    addInt16(value) {
        this.prep(2, 0);
        this.writeInt16(value);
    }
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the buffer.
     */
    addInt32(value) {
        this.prep(4, 0);
        this.writeInt32(value);
    }
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the buffer.
     */
    addInt64(value) {
        this.prep(8, 0);
        this.writeInt64(value);
    }
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the buffer.
     */
    addFloat32(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
    }
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the buffer.
     */
    addFloat64(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt8(value);
            this.slot(voffset);
        }
    }
    addFieldInt16(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt16(value);
            this.slot(voffset);
        }
    }
    addFieldInt32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt32(value);
            this.slot(voffset);
        }
    }
    addFieldInt64(voffset, value, defaultValue) {
        if (this.force_defaults || value !== defaultValue) {
            this.addInt64(value);
            this.slot(voffset);
        }
    }
    addFieldFloat32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat32(value);
            this.slot(voffset);
        }
    }
    addFieldFloat64(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat64(value);
            this.slot(voffset);
        }
    }
    addFieldOffset(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addOffset(value);
            this.slot(voffset);
        }
    }
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */
    addFieldStruct(voffset, value, defaultValue) {
        if (value != defaultValue) {
            this.nested(value);
            this.slot(voffset);
        }
    }
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */
    nested(obj) {
        if (obj != this.offset()) {
            throw new TypeError('FlatBuffers: struct must be serialized inline.');
        }
    }
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    notNested() {
        if (this.isNested) {
            throw new TypeError('FlatBuffers: object serialization must not be nested.');
        }
    }
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */
    slot(voffset) {
        if (this.vtable !== null)
            this.vtable[voffset] = this.offset();
    }
    /**
     * @returns Offset relative to the end of the buffer.
     */
    offset() {
        return this.bb.capacity() - this.space;
    }
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    static growByteBuffer(bb) {
        const old_buf_size = bb.capacity();
        // Ensure we don't grow beyond what fits in an int.
        if (old_buf_size & 0xC0000000) {
            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
        }
        const new_buf_size = old_buf_size << 1;
        const nbb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
    }
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */
    addOffset(offset) {
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, 0); // Ensure alignment is already done.
        this.writeInt32(this.offset() - offset + _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT);
    }
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */
    startObject(numfields) {
        this.notNested();
        if (this.vtable == null) {
            this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (let i = 0; i < numfields; i++) {
            this.vtable[i] = 0; // This will push additional elements as needed
        }
        this.isNested = true;
        this.object_start = this.offset();
    }
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */
    endObject() {
        if (this.vtable == null || !this.isNested) {
            throw new Error('FlatBuffers: endObject called without startObject');
        }
        this.addInt32(0);
        const vtableloc = this.offset();
        // Trim trailing zeroes.
        let i = this.vtable_in_use - 1;
        // eslint-disable-next-line no-empty
        for (; i >= 0 && this.vtable[i] == 0; i--) { }
        const trimmed_size = i + 1;
        // Write out the current vtable.
        for (; i >= 0; i--) {
            // Offset relative to the start of the table.
            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        const standard_fields = 2; // The fields below:
        this.addInt16(vtableloc - this.object_start);
        const len = (trimmed_size + standard_fields) * _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT;
        this.addInt16(len);
        // Search for an existing vtable that matches the current one.
        let existing_vtable = 0;
        const vt1 = this.space;
        outer_loop: for (i = 0; i < this.vtables.length; i++) {
            const vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
                for (let j = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT; j < len; j += _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT) {
                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                        continue outer_loop;
                    }
                }
                existing_vtable = this.vtables[i];
                break;
            }
        }
        if (existing_vtable) {
            // Found a match:
            // Remove the current vtable.
            this.space = this.bb.capacity() - vtableloc;
            // Point table to existing vtable.
            this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        }
        else {
            // No match:
            // Add the location of the current vtable to the list of vtables.
            this.vtables.push(this.offset());
            // Point table to current vtable.
            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
    }
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */
    finish(root_table, opt_file_identifier, opt_size_prefix) {
        const size_prefix = opt_size_prefix ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
            const file_identifier = opt_file_identifier;
            this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT +
                _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH + size_prefix);
            if (file_identifier.length != _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH) {
                throw new TypeError('FlatBuffers: file identifier must be length ' +
                    _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH);
            }
            for (let i = _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
                this.writeInt8(file_identifier.charCodeAt(i));
            }
        }
        this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
            this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
    }
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */
    finishSizePrefixed(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
    }
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */
    requiredField(table, field) {
        const table_start = this.bb.capacity() - table;
        const vtable_start = table_start - this.bb.readInt32(table_start);
        const ok = field < this.bb.readInt16(vtable_start) &&
            this.bb.readInt16(vtable_start + field) != 0;
        // If this fails, the caller will show what field needs to be set.
        if (!ok) {
            throw new TypeError('FlatBuffers: field ' + field + ' must be set');
        }
    }
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */
    startVector(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
    }
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */
    endVector() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createSharedString(s) {
        if (!s) {
            return 0;
        }
        if (!this.string_maps) {
            this.string_maps = new Map();
        }
        if (this.string_maps.has(s)) {
            return this.string_maps.get(s);
        }
        const offset = this.createString(s);
        this.string_maps.set(s, offset);
        return offset;
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createString(s) {
        if (s === null || s === undefined) {
            return 0;
        }
        let utf8;
        if (s instanceof Uint8Array) {
            utf8 = s;
        }
        else {
            utf8 = this.text_encoder.encode(s);
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
            bytes[offset++] = utf8[i];
        }
        return this.endVector();
    }
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */
    createObjectOffset(obj) {
        if (obj === null) {
            return 0;
        }
        if (typeof obj === 'string') {
            return this.createString(obj);
        }
        else {
            return obj.pack(this);
        }
    }
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */
    createObjectOffsetList(list) {
        const ret = [];
        for (let i = 0; i < list.length; ++i) {
            const val = list[i];
            if (val !== null) {
                ret.push(this.createObjectOffset(val));
            }
            else {
                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
            }
        }
        return ret;
    }
    createStructOffsetList(list, startFunc) {
        startFunc(this, list.length);
        this.createObjectOffsetList(list.slice().reverse());
        return this.endVector();
    }
}


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/byte-buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/byte-buffer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ByteBuffer: () => (/* binding */ ByteBuffer)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/flatbuffers/mjs/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/flatbuffers/mjs/utils.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/flatbuffers/mjs/encoding.js");



class ByteBuffer {
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
     */
    constructor(bytes_) {
        this.bytes_ = bytes_;
        this.position_ = 0;
        this.text_decoder_ = new TextDecoder();
    }
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */
    static allocate(byte_size) {
        return new ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
        this.position_ = 0;
    }
    /**
     * Get the underlying `Uint8Array`.
     */
    bytes() {
        return this.bytes_;
    }
    /**
     * Get the buffer's position.
     */
    position() {
        return this.position_;
    }
    /**
     * Set the buffer's position.
     */
    setPosition(position) {
        this.position_ = position;
    }
    /**
     * Get the buffer's capacity.
     */
    capacity() {
        return this.bytes_.length;
    }
    readInt8(offset) {
        return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
        return this.bytes_[offset];
    }
    readInt16(offset) {
        return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
        return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0] = this.readInt32(offset);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0];
    }
    readFloat64(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1] = this.readInt32(offset);
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0];
    }
    writeInt8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0]);
    }
    writeFloat64(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0]);
    }
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */
    getBufferIdentifier() {
        if (this.bytes_.length < this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT +
            _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
        }
        let result = "";
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            result += String.fromCharCode(this.readInt8(this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i));
        }
        return result;
    }
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */
    __offset(bb_pos, vtable_offset) {
        const vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */
    __union(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
    }
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
     * "optionalEncoding" argument. This is useful for avoiding conversion when
     * the data will just be packaged back up in another FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */
    __string(offset, opt_encoding) {
        offset += this.readInt32(offset);
        const length = this.readInt32(offset);
        offset += _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT;
        const utf8bytes = this.bytes_.subarray(offset, offset + length);
        if (opt_encoding === _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding.UTF8_BYTES)
            return utf8bytes;
        else
            return this.text_decoder_.decode(utf8bytes);
    }
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */
    __union_with_string(o, offset) {
        if (typeof o === 'string') {
            return this.__string(offset);
        }
        return this.__union(o, offset);
    }
    /**
     * Retrieve the relative offset stored at "offset"
     */
    __indirect(offset) {
        return offset + this.readInt32(offset);
    }
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */
    __vector(offset) {
        return offset + this.readInt32(offset) + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT; // data starts after the length
    }
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */
    __vector_len(offset) {
        return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
        if (ident.length != _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: file identifier must be length ' +
                _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH);
        }
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            if (ident.charCodeAt(i) != this.readInt8(this.position() + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * A helper function for generating list for obj api
     */
    createScalarList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val);
            }
        }
        return ret;
    }
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */
    createObjList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val.unpack());
            }
        }
        return ret;
    }
}


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* binding */ FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* binding */ SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* binding */ SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* binding */ SIZE_PREFIX_LENGTH)
/* harmony export */ });
const SIZEOF_SHORT = 2;
const SIZEOF_INT = 4;
const FILE_IDENTIFIER_LENGTH = 4;
const SIZE_PREFIX_LENGTH = 4;


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/encoding.js":
/*!**************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/encoding.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Encoding: () => (/* binding */ Encoding)
/* harmony export */ });
var Encoding;
(function (Encoding) {
    Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/flatbuffers.js":
/*!*****************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/flatbuffers.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* reexport safe */ _builder_js__WEBPACK_IMPORTED_MODULE_3__.Builder),
/* harmony export */   ByteBuffer: () => (/* reexport safe */ _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__.ByteBuffer),
/* harmony export */   Encoding: () => (/* reexport safe */ _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding),
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH),
/* harmony export */   float32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32),
/* harmony export */   float64: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64),
/* harmony export */   int32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32),
/* harmony export */   isLittleEndian: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/flatbuffers/mjs/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/flatbuffers/mjs/utils.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/flatbuffers/mjs/encoding.js");
/* harmony import */ var _builder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./builder.js */ "./node_modules/flatbuffers/mjs/builder.js");
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./byte-buffer.js */ "./node_modules/flatbuffers/mjs/byte-buffer.js");










/***/ }),

/***/ "./node_modules/flatbuffers/mjs/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/flatbuffers/mjs/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   float32: () => (/* binding */ float32),
/* harmony export */   float64: () => (/* binding */ float64),
/* harmony export */   int32: () => (/* binding */ int32),
/* harmony export */   isLittleEndian: () => (/* binding */ isLittleEndian)
/* harmony export */ });
const int32 = new Int32Array(2);
const float32 = new Float32Array(int32.buffer);
const float64 = new Float64Array(int32.buffer);
const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;


/***/ }),

/***/ "./node_modules/openmeteo/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/openmeteo/lib/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchWeatherApi = void 0;
const flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js");
const weather_api_response_1 = __webpack_require__(/*! @openmeteo/sdk/weather-api-response */ "./node_modules/@openmeteo/sdk/weather-api-response.js");
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
function fetchRetried(url, retries = 3, backoffFactor = 0.5, backoffMax = 2) {
    return __awaiter(this, void 0, void 0, function* () {
        const statusToRetry = [500, 502, 504];
        const statusWithJsonError = [400, 429];
        let currentTry = 0;
        let response = yield fetch(url);
        while (statusToRetry.includes(response.status)) {
            currentTry++;
            if (currentTry >= retries) {
                throw new Error(response.statusText);
            }
            const sleepMs = Math.min(backoffFactor * Math.pow(2, currentTry), backoffMax) * 1000;
            yield sleep(sleepMs);
            response = yield fetch(url);
        }
        if (statusWithJsonError.includes(response.status)) {
            const json = yield response.json();
            if ('reason' in json) {
                throw new Error(json.reason);
            }
            throw new Error(response.statusText);
        }
        return response;
    });
}
/**
 * Retrieve data from the Open-Meteo weather API
 *
 * @param {string} url Server and endpoint. E.g. "https://api.open-meteo.com/v1/forecast"
 * @param {any} params URL parameter as an object
 * @param {number} [retries=3] Number of retries in case of an server error
 * @param {number} [backoffFactor=0.2] Exponential backoff factor to increase wait time after each retry
 * @param {number} [backoffMax=2] Maximum wait time between retries
 * @returns {Promise<WeatherApiResponse[]>}
 */
function fetchWeatherApi(url, params, retries = 3, backoffFactor = 0.2, backoffMax = 2) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlParams = new URLSearchParams(params);
        urlParams.set('format', 'flatbuffers');
        const response = yield fetchRetried(`${url}?${urlParams.toString()}`, retries, backoffFactor, backoffMax);
        const fb = new flatbuffers_1.ByteBuffer(new Uint8Array(yield response.arrayBuffer()));
        const results = [];
        let pos = 0;
        while (pos < fb.capacity()) {
            fb.setPosition(pos);
            const len = fb.readInt32(fb.position());
            results.push(weather_api_response_1.WeatherApiResponse.getSizePrefixedRootAsWeatherApiResponse(fb));
            pos += len + 4;
        }
        return results;
    });
}
exports.fetchWeatherApi = fetchWeatherApi;


/***/ }),

/***/ "./src/print.js":
/*!**********************!*\
  !*** ./src/print.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ grapher),
/* harmony export */   destroy: () => (/* binding */ destroy)
/* harmony export */ });
const ctx = document.getElementById("chart");
let c;
async function grapher(latitude, longitude, day, day_night) {
	const temps = await getDaily(latitude, longitude);
	const dayTemp = temps[day];
  let color = day_night == 0 ? "rgb(250, 158, 66)" : 'rgb(113,63,253)';

	c = new Chart(ctx, {
	  type: "line",
	  data: {
		labels: [
		  "12AM",
		  "1AM",
		  "2AM",
		  "3AM",
		  "4AM",
		  "5AM",
		  "6AM",
		  "7AM",
		  "8AM",
		  "9AM",
		  "10AM",
		  "11AM",
		  "12PM",
		  "1PM",
		  "2PM",
		  "3PM",
		  "4PM",
		  "5PM",
		  "6PM",
		  "7PM",
		  "8PM",
		  "9PM",
		  "10PM",
		  "11PM",
		],
		datasets: [
		  {
			label: "Temp in C°",
			data: dayTemp,
      borderColor: color,
			borderWidth: 1,
		  },
		],
	  },
	  options: {
		scales: {
		  y: {
			beginAtZero: true,
		  },
		},
	  },
	});


  }

function destroy() {
  c.destroy()
}
  

async function getDaily(latitude, longitude) {
  try {
	let days = [];
    const fetchWeatherApi = (__webpack_require__(/*! openmeteo */ "./node_modules/openmeteo/lib/index.js").fetchWeatherApi);
    const params = {
      latitude: latitude,
      longitude: longitude,
      hourly: "temperature_2m",
    };
    const url = "https://api.open-meteo.com/v1/forecast";

    const responses = await fetchWeatherApi(url, params);

    // Helper function to form time ranges
    const range = (start, stop, step) =>
      Array.from({ length: (stop - start) / step }, (_, i) => start + i * step);
    // Process first location. Add a for-loop for multiple locations or weather models
    const response = responses[0];
    // Attributes for timezone and location
    const utcOffsetSeconds = response.utcOffsetSeconds();
    const timezone = response.timezone();
    const timezoneAbbreviation = response.timezoneAbbreviation();
    //const latitude = response.latitude();
    //const longitude = response.longitude();
    const hourly = response.hourly();
    // Note: The order of weather variables in the URL query and the indices below need to match!
    const weatherData = {
      hourly: {
        time: range(
          Number(hourly.time()),
          Number(hourly.timeEnd()),
          hourly.interval()
        ).map((t) => new Date((t + utcOffsetSeconds) * 1000)),
        temperature2m: hourly.variables(0).valuesArray(),
      },
    };
    // `weatherData` now contains a simple structure with arrays for datetime and weather data

    let day = [];
    let count = 0;
    let dayno = 0;
    for (let i = 0; i < weatherData.hourly.time.length; i++) {
      if (dayno >= 3) {
        break;
      }
      if (count < 24) {
        day.push(weatherData.hourly.temperature2m[i].toFixed(2));
        count++;
      } else {
        count = 0;
        dayno++;
        //days.push(day);
        days.push(day);
        day = [];
        day.push(weatherData.hourly.temperature2m[i].toFixed(2));
        count++;
      }
    }

    return days;
  } catch (e) {
    console.error("error during hour fetch", e);
  }
}


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/print.js"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJpbnQuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0IsbUJBQW1CLG1CQUFtQjs7Ozs7Ozs7Ozs7QUNqQjVDO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsWUFBWSxhQUFhLGFBQWE7Ozs7Ozs7Ozs7O0FDbkUxQjtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsV0FBVyxZQUFZLFlBQVk7Ozs7Ozs7Ozs7O0FDL0N2QjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsaUNBQWlDLG1CQUFPLENBQUMsa0VBQWE7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsc0VBQWtCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHdEQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLGdFQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7Ozs7Ozs7Ozs7QUM3R2I7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZSxnQkFBZ0IsZ0JBQWdCOzs7Ozs7Ozs7OztBQ2xIbkM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGlDQUFpQyxtQkFBTyxDQUFDLGtFQUFhO0FBQ3RELGtDQUFrQyxtQkFBTyxDQUFDLHdGQUEyQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOzs7Ozs7Ozs7OztBQ25FWjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsaUNBQWlDLG1CQUFPLENBQUMsa0VBQWE7QUFDdEQsbUJBQW1CLG1CQUFPLENBQUMsMERBQVk7QUFDdkMsaUNBQWlDLG1CQUFPLENBQUMsc0ZBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEdvQjtBQUN3RDtBQUMvRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsSUFBSTtBQUNKLEVBQUU7OztBQUdGOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrRkFBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYXNpYy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab3Blbm1ldGVvL3Nkay9hZ2dyZWdhdGlvbi5qcyIsIndlYnBhY2s6Ly9iYXNpYy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab3Blbm1ldGVvL3Nkay9tb2RlbC5qcyIsIndlYnBhY2s6Ly9iYXNpYy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab3Blbm1ldGVvL3Nkay91bml0LmpzIiwid2VicGFjazovL2Jhc2ljLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BvcGVubWV0ZW8vc2RrL3ZhcmlhYmxlLXdpdGgtdmFsdWVzLmpzIiwid2VicGFjazovL2Jhc2ljLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BvcGVubWV0ZW8vc2RrL3ZhcmlhYmxlLmpzIiwid2VicGFjazovL2Jhc2ljLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BvcGVubWV0ZW8vc2RrL3ZhcmlhYmxlcy13aXRoLXRpbWUuanMiLCJ3ZWJwYWNrOi8vYmFzaWMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9wZW5tZXRlby9zZGsvd2VhdGhlci1hcGktcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vYmFzaWMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vYmFzaWMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2J5dGUtYnVmZmVyLmpzIiwid2VicGFjazovL2Jhc2ljLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vYmFzaWMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2VuY29kaW5nLmpzIiwid2VicGFjazovL2Jhc2ljLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9mbGF0YnVmZmVycy5qcyIsIndlYnBhY2s6Ly9iYXNpYy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vYmFzaWMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvb3Blbm1ldGVvL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9iYXNpYy10ZW1wbGF0ZS8uL3NyYy9wcmludC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZ2dyZWdhdGlvbiA9IHZvaWQgMDtcbnZhciBBZ2dyZWdhdGlvbjtcbihmdW5jdGlvbiAoQWdncmVnYXRpb24pIHtcbiAgICBBZ2dyZWdhdGlvbltBZ2dyZWdhdGlvbltcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wibWluaW11bVwiXSA9IDFdID0gXCJtaW5pbXVtXCI7XG4gICAgQWdncmVnYXRpb25bQWdncmVnYXRpb25bXCJtYXhpbXVtXCJdID0gMl0gPSBcIm1heGltdW1cIjtcbiAgICBBZ2dyZWdhdGlvbltBZ2dyZWdhdGlvbltcIm1lYW5cIl0gPSAzXSA9IFwibWVhblwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDEwXCJdID0gNF0gPSBcInAxMFwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDI1XCJdID0gNV0gPSBcInAyNVwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wibWVkaWFuXCJdID0gNl0gPSBcIm1lZGlhblwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDc1XCJdID0gN10gPSBcInA3NVwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDkwXCJdID0gOF0gPSBcInA5MFwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wiZG9taW5hbnRcIl0gPSA5XSA9IFwiZG9taW5hbnRcIjtcbiAgICBBZ2dyZWdhdGlvbltBZ2dyZWdhdGlvbltcInN1bVwiXSA9IDEwXSA9IFwic3VtXCI7XG59KShBZ2dyZWdhdGlvbiB8fCAoZXhwb3J0cy5BZ2dyZWdhdGlvbiA9IEFnZ3JlZ2F0aW9uID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyLCBkbyBub3QgbW9kaWZ5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGVsID0gdm9pZCAwO1xudmFyIE1vZGVsO1xuKGZ1bmN0aW9uIChNb2RlbCkge1xuICAgIE1vZGVsW01vZGVsW1widW5kZWZpbmVkXCJdID0gMF0gPSBcInVuZGVmaW5lZFwiO1xuICAgIE1vZGVsW01vZGVsW1wiYmVzdF9tYXRjaFwiXSA9IDFdID0gXCJiZXN0X21hdGNoXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnZnNfc2VhbWxlc3NcIl0gPSAyXSA9IFwiZ2ZzX3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnZnNfZ2xvYmFsXCJdID0gM10gPSBcImdmc19nbG9iYWxcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdmc19ocnJyXCJdID0gNF0gPSBcImdmc19ocnJyXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJtZXRlb2ZyYW5jZV9zZWFtbGVzc1wiXSA9IDVdID0gXCJtZXRlb2ZyYW5jZV9zZWFtbGVzc1wiO1xuICAgIE1vZGVsW01vZGVsW1wibWV0ZW9mcmFuY2VfYXJwZWdlX3NlYW1sZXNzXCJdID0gNl0gPSBcIm1ldGVvZnJhbmNlX2FycGVnZV9zZWFtbGVzc1wiO1xuICAgIE1vZGVsW01vZGVsW1wibWV0ZW9mcmFuY2VfYXJwZWdlX3dvcmxkXCJdID0gN10gPSBcIm1ldGVvZnJhbmNlX2FycGVnZV93b3JsZFwiO1xuICAgIE1vZGVsW01vZGVsW1wibWV0ZW9mcmFuY2VfYXJwZWdlX2V1cm9wZVwiXSA9IDhdID0gXCJtZXRlb2ZyYW5jZV9hcnBlZ2VfZXVyb3BlXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJtZXRlb2ZyYW5jZV9hcm9tZV9zZWFtbGVzc1wiXSA9IDldID0gXCJtZXRlb2ZyYW5jZV9hcm9tZV9zZWFtbGVzc1wiO1xuICAgIE1vZGVsW01vZGVsW1wibWV0ZW9mcmFuY2VfYXJvbWVfZnJhbmNlXCJdID0gMTBdID0gXCJtZXRlb2ZyYW5jZV9hcm9tZV9mcmFuY2VcIjtcbiAgICBNb2RlbFtNb2RlbFtcIm1ldGVvZnJhbmNlX2Fyb21lX2ZyYW5jZV9oZFwiXSA9IDExXSA9IFwibWV0ZW9mcmFuY2VfYXJvbWVfZnJhbmNlX2hkXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJqbWFfc2VhbWxlc3NcIl0gPSAxMl0gPSBcImptYV9zZWFtbGVzc1wiO1xuICAgIE1vZGVsW01vZGVsW1wiam1hX21zbVwiXSA9IDEzXSA9IFwiam1hX21zbVwiO1xuICAgIE1vZGVsW01vZGVsW1wiam1zX2dzbVwiXSA9IDE0XSA9IFwiam1zX2dzbVwiO1xuICAgIE1vZGVsW01vZGVsW1wiam1hX2dzbVwiXSA9IDE1XSA9IFwiam1hX2dzbVwiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2VtX3NlYW1sZXNzXCJdID0gMTZdID0gXCJnZW1fc2VhbWxlc3NcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdlbV9nbG9iYWxcIl0gPSAxN10gPSBcImdlbV9nbG9iYWxcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdlbV9yZWdpb25hbFwiXSA9IDE4XSA9IFwiZ2VtX3JlZ2lvbmFsXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnZW1faHJkcHNfY29udGluZW50YWxcIl0gPSAxOV0gPSBcImdlbV9ocmRwc19jb250aW5lbnRhbFwiO1xuICAgIE1vZGVsW01vZGVsW1wiaWNvbl9zZWFtbGVzc1wiXSA9IDIwXSA9IFwiaWNvbl9zZWFtbGVzc1wiO1xuICAgIE1vZGVsW01vZGVsW1wiaWNvbl9nbG9iYWxcIl0gPSAyMV0gPSBcImljb25fZ2xvYmFsXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJpY29uX2V1XCJdID0gMjJdID0gXCJpY29uX2V1XCI7XG4gICAgTW9kZWxbTW9kZWxbXCJpY29uX2QyXCJdID0gMjNdID0gXCJpY29uX2QyXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJlY213Zl9pZnMwNFwiXSA9IDI0XSA9IFwiZWNtd2ZfaWZzMDRcIjtcbiAgICBNb2RlbFtNb2RlbFtcIm1ldG5vX25vcmRpY1wiXSA9IDI1XSA9IFwibWV0bm9fbm9yZGljXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJlcmE1X3NlYW1sZXNzXCJdID0gMjZdID0gXCJlcmE1X3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJlcmE1XCJdID0gMjddID0gXCJlcmE1XCI7XG4gICAgTW9kZWxbTW9kZWxbXCJjZXJyYVwiXSA9IDI4XSA9IFwiY2VycmFcIjtcbiAgICBNb2RlbFtNb2RlbFtcImVyYTVfbGFuZFwiXSA9IDI5XSA9IFwiZXJhNV9sYW5kXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJlY213Zl9pZnNcIl0gPSAzMF0gPSBcImVjbXdmX2lmc1wiO1xuICAgIE1vZGVsW01vZGVsW1wiZ3dhbVwiXSA9IDMxXSA9IFwiZ3dhbVwiO1xuICAgIE1vZGVsW01vZGVsW1wiZXdhbVwiXSA9IDMyXSA9IFwiZXdhbVwiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2xvZmFzX3NlYW1sZXNzX3YzXCJdID0gMzNdID0gXCJnbG9mYXNfc2VhbWxlc3NfdjNcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdsb2Zhc19mb3JlY2FzdF92M1wiXSA9IDM0XSA9IFwiZ2xvZmFzX2ZvcmVjYXN0X3YzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnbG9mYXNfY29uc29saWRhdGVkX3YzXCJdID0gMzVdID0gXCJnbG9mYXNfY29uc29saWRhdGVkX3YzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnbG9mYXNfc2VhbWxlc3NfdjRcIl0gPSAzNl0gPSBcImdsb2Zhc19zZWFtbGVzc192NFwiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2xvZmFzX2ZvcmVjYXN0X3Y0XCJdID0gMzddID0gXCJnbG9mYXNfZm9yZWNhc3RfdjRcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdsb2Zhc19jb25zb2xpZGF0ZWRfdjRcIl0gPSAzOF0gPSBcImdsb2Zhc19jb25zb2xpZGF0ZWRfdjRcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdmczAyNVwiXSA9IDM5XSA9IFwiZ2ZzMDI1XCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnZnMwNVwiXSA9IDQwXSA9IFwiZ2ZzMDVcIjtcbiAgICBNb2RlbFtNb2RlbFtcIkNNQ0NfQ00yX1ZIUjRcIl0gPSA0MV0gPSBcIkNNQ0NfQ00yX1ZIUjRcIjtcbiAgICBNb2RlbFtNb2RlbFtcIkZHT0FMU19mM19IX2hpZ2hyZXNTU1RcIl0gPSA0Ml0gPSBcIkZHT0FMU19mM19IX2hpZ2hyZXNTU1RcIjtcbiAgICBNb2RlbFtNb2RlbFtcIkZHT0FMU19mM19IXCJdID0gNDNdID0gXCJGR09BTFNfZjNfSFwiO1xuICAgIE1vZGVsW01vZGVsW1wiSGlSQU1fU0lUX0hSXCJdID0gNDRdID0gXCJIaVJBTV9TSVRfSFJcIjtcbiAgICBNb2RlbFtNb2RlbFtcIk1SSV9BR0NNM18yX1NcIl0gPSA0NV0gPSBcIk1SSV9BR0NNM18yX1NcIjtcbiAgICBNb2RlbFtNb2RlbFtcIkVDX0VhcnRoM1BfSFJcIl0gPSA0Nl0gPSBcIkVDX0VhcnRoM1BfSFJcIjtcbiAgICBNb2RlbFtNb2RlbFtcIk1QSV9FU00xXzJfWFJcIl0gPSA0N10gPSBcIk1QSV9FU00xXzJfWFJcIjtcbiAgICBNb2RlbFtNb2RlbFtcIk5JQ0FNMTZfOFNcIl0gPSA0OF0gPSBcIk5JQ0FNMTZfOFNcIjtcbiAgICBNb2RlbFtNb2RlbFtcImNhbXNfZXVyb3BlXCJdID0gNDldID0gXCJjYW1zX2V1cm9wZVwiO1xuICAgIE1vZGVsW01vZGVsW1wiY2Ftc19nbG9iYWxcIl0gPSA1MF0gPSBcImNhbXNfZ2xvYmFsXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJjZnN2MlwiXSA9IDUxXSA9IFwiY2ZzdjJcIjtcbiAgICBNb2RlbFtNb2RlbFtcImVyYTVfb2NlYW5cIl0gPSA1Ml0gPSBcImVyYTVfb2NlYW5cIjtcbiAgICBNb2RlbFtNb2RlbFtcImNtYV9ncmFwZXNfZ2xvYmFsXCJdID0gNTNdID0gXCJjbWFfZ3JhcGVzX2dsb2JhbFwiO1xuICAgIE1vZGVsW01vZGVsW1wiYm9tX2FjY2Vzc19nbG9iYWxcIl0gPSA1NF0gPSBcImJvbV9hY2Nlc3NfZ2xvYmFsXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJib21fYWNjZXNzX2dsb2JhbF9lbnNlbWJsZVwiXSA9IDU1XSA9IFwiYm9tX2FjY2Vzc19nbG9iYWxfZW5zZW1ibGVcIjtcbiAgICBNb2RlbFtNb2RlbFtcImFycGFlX2Nvc21vX3NlYW1sZXNzXCJdID0gNTZdID0gXCJhcnBhZV9jb3Ntb19zZWFtbGVzc1wiO1xuICAgIE1vZGVsW01vZGVsW1wiYXJwYWVfY29zbW9fMmlcIl0gPSA1N10gPSBcImFycGFlX2Nvc21vXzJpXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJhcnBhZV9jb3Ntb18yaV9ydWNcIl0gPSA1OF0gPSBcImFycGFlX2Nvc21vXzJpX3J1Y1wiO1xuICAgIE1vZGVsW01vZGVsW1wiYXJwYWVfY29zbW9fNW1cIl0gPSA1OV0gPSBcImFycGFlX2Nvc21vXzVtXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJlY213Zl9pZnMwMjVcIl0gPSA2MF0gPSBcImVjbXdmX2lmczAyNVwiO1xufSkoTW9kZWwgfHwgKGV4cG9ydHMuTW9kZWwgPSBNb2RlbCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vbml0ID0gdm9pZCAwO1xudmFyIFVuaXQ7XG4oZnVuY3Rpb24gKFVuaXQpIHtcbiAgICBVbml0W1VuaXRbXCJ1bmRlZmluZWRcIl0gPSAwXSA9IFwidW5kZWZpbmVkXCI7XG4gICAgVW5pdFtVbml0W1wiY2Vsc2l1c1wiXSA9IDFdID0gXCJjZWxzaXVzXCI7XG4gICAgVW5pdFtVbml0W1wiY2VudGltZXRyZVwiXSA9IDJdID0gXCJjZW50aW1ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wiY3ViaWNfbWV0cmVfcGVyX2N1YmljX21ldHJlXCJdID0gM10gPSBcImN1YmljX21ldHJlX3Blcl9jdWJpY19tZXRyZVwiO1xuICAgIFVuaXRbVW5pdFtcImN1YmljX21ldHJlX3Blcl9zZWNvbmRcIl0gPSA0XSA9IFwiY3ViaWNfbWV0cmVfcGVyX3NlY29uZFwiO1xuICAgIFVuaXRbVW5pdFtcImRlZ3JlZV9kaXJlY3Rpb25cIl0gPSA1XSA9IFwiZGVncmVlX2RpcmVjdGlvblwiO1xuICAgIFVuaXRbVW5pdFtcImRpbWVuc2lvbmxlc3NfaW50ZWdlclwiXSA9IDZdID0gXCJkaW1lbnNpb25sZXNzX2ludGVnZXJcIjtcbiAgICBVbml0W1VuaXRbXCJkaW1lbnNpb25sZXNzXCJdID0gN10gPSBcImRpbWVuc2lvbmxlc3NcIjtcbiAgICBVbml0W1VuaXRbXCJldXJvcGVhbl9haXJfcXVhbGl0eV9pbmRleFwiXSA9IDhdID0gXCJldXJvcGVhbl9haXJfcXVhbGl0eV9pbmRleFwiO1xuICAgIFVuaXRbVW5pdFtcImZhaHJlbmhlaXRcIl0gPSA5XSA9IFwiZmFocmVuaGVpdFwiO1xuICAgIFVuaXRbVW5pdFtcImZlZXRcIl0gPSAxMF0gPSBcImZlZXRcIjtcbiAgICBVbml0W1VuaXRbXCJmcmFjdGlvblwiXSA9IDExXSA9IFwiZnJhY3Rpb25cIjtcbiAgICBVbml0W1VuaXRbXCJnZGRfY2Vsc2l1c1wiXSA9IDEyXSA9IFwiZ2RkX2NlbHNpdXNcIjtcbiAgICBVbml0W1VuaXRbXCJnZW9wb3RlbnRpYWxfbWV0cmVcIl0gPSAxM10gPSBcImdlb3BvdGVudGlhbF9tZXRyZVwiO1xuICAgIFVuaXRbVW5pdFtcImdyYWluc19wZXJfY3ViaWNfbWV0cmVcIl0gPSAxNF0gPSBcImdyYWluc19wZXJfY3ViaWNfbWV0cmVcIjtcbiAgICBVbml0W1VuaXRbXCJncmFtX3Blcl9raWxvZ3JhbVwiXSA9IDE1XSA9IFwiZ3JhbV9wZXJfa2lsb2dyYW1cIjtcbiAgICBVbml0W1VuaXRbXCJoZWN0b3Bhc2NhbFwiXSA9IDE2XSA9IFwiaGVjdG9wYXNjYWxcIjtcbiAgICBVbml0W1VuaXRbXCJob3Vyc1wiXSA9IDE3XSA9IFwiaG91cnNcIjtcbiAgICBVbml0W1VuaXRbXCJpbmNoXCJdID0gMThdID0gXCJpbmNoXCI7XG4gICAgVW5pdFtVbml0W1wiaXNvODYwMVwiXSA9IDE5XSA9IFwiaXNvODYwMVwiO1xuICAgIFVuaXRbVW5pdFtcImpvdWxlX3Blcl9raWxvZ3JhbVwiXSA9IDIwXSA9IFwiam91bGVfcGVyX2tpbG9ncmFtXCI7XG4gICAgVW5pdFtVbml0W1wia2VsdmluXCJdID0gMjFdID0gXCJrZWx2aW5cIjtcbiAgICBVbml0W1VuaXRbXCJraWxvcGFzY2FsXCJdID0gMjJdID0gXCJraWxvcGFzY2FsXCI7XG4gICAgVW5pdFtVbml0W1wia2lsb2dyYW1fcGVyX3NxdWFyZV9tZXRyZVwiXSA9IDIzXSA9IFwia2lsb2dyYW1fcGVyX3NxdWFyZV9tZXRyZVwiO1xuICAgIFVuaXRbVW5pdFtcImtpbG9tZXRyZXNfcGVyX2hvdXJcIl0gPSAyNF0gPSBcImtpbG9tZXRyZXNfcGVyX2hvdXJcIjtcbiAgICBVbml0W1VuaXRbXCJrbm90c1wiXSA9IDI1XSA9IFwia25vdHNcIjtcbiAgICBVbml0W1VuaXRbXCJtZWdham91bGVfcGVyX3NxdWFyZV9tZXRyZVwiXSA9IDI2XSA9IFwibWVnYWpvdWxlX3Blcl9zcXVhcmVfbWV0cmVcIjtcbiAgICBVbml0W1VuaXRbXCJtZXRyZV9wZXJfc2Vjb25kX25vdF91bml0X2NvbnZlcnRlZFwiXSA9IDI3XSA9IFwibWV0cmVfcGVyX3NlY29uZF9ub3RfdW5pdF9jb252ZXJ0ZWRcIjtcbiAgICBVbml0W1VuaXRbXCJtZXRyZV9wZXJfc2Vjb25kXCJdID0gMjhdID0gXCJtZXRyZV9wZXJfc2Vjb25kXCI7XG4gICAgVW5pdFtVbml0W1wibWV0cmVcIl0gPSAyOV0gPSBcIm1ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wibWljcm9ncmFtc19wZXJfY3ViaWNfbWV0cmVcIl0gPSAzMF0gPSBcIm1pY3JvZ3JhbXNfcGVyX2N1YmljX21ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wibWlsZXNfcGVyX2hvdXJcIl0gPSAzMV0gPSBcIm1pbGVzX3Blcl9ob3VyXCI7XG4gICAgVW5pdFtVbml0W1wibWlsbGltZXRyZVwiXSA9IDMyXSA9IFwibWlsbGltZXRyZVwiO1xuICAgIFVuaXRbVW5pdFtcInBhc2NhbFwiXSA9IDMzXSA9IFwicGFzY2FsXCI7XG4gICAgVW5pdFtVbml0W1wicGVyX3NlY29uZFwiXSA9IDM0XSA9IFwicGVyX3NlY29uZFwiO1xuICAgIFVuaXRbVW5pdFtcInBlcmNlbnRhZ2VcIl0gPSAzNV0gPSBcInBlcmNlbnRhZ2VcIjtcbiAgICBVbml0W1VuaXRbXCJzZWNvbmRzXCJdID0gMzZdID0gXCJzZWNvbmRzXCI7XG4gICAgVW5pdFtVbml0W1widW5peF90aW1lXCJdID0gMzddID0gXCJ1bml4X3RpbWVcIjtcbiAgICBVbml0W1VuaXRbXCJ1c19haXJfcXVhbGl0eV9pbmRleFwiXSA9IDM4XSA9IFwidXNfYWlyX3F1YWxpdHlfaW5kZXhcIjtcbiAgICBVbml0W1VuaXRbXCJ3YXR0X3Blcl9zcXVhcmVfbWV0cmVcIl0gPSAzOV0gPSBcIndhdHRfcGVyX3NxdWFyZV9tZXRyZVwiO1xuICAgIFVuaXRbVW5pdFtcIndtb19jb2RlXCJdID0gNDBdID0gXCJ3bW9fY29kZVwiO1xufSkoVW5pdCB8fCAoZXhwb3J0cy5Vbml0ID0gVW5pdCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlV2l0aFZhbHVlcyA9IHZvaWQgMDtcbmNvbnN0IGZsYXRidWZmZXJzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJmbGF0YnVmZmVyc1wiKSk7XG5jb25zdCBhZ2dyZWdhdGlvbl9qc18xID0gcmVxdWlyZShcIi4vYWdncmVnYXRpb24uanNcIik7XG5jb25zdCB1bml0X2pzXzEgPSByZXF1aXJlKFwiLi91bml0LmpzXCIpO1xuY29uc3QgdmFyaWFibGVfanNfMSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlLmpzXCIpO1xuY2xhc3MgVmFyaWFibGVXaXRoVmFsdWVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iYiA9IG51bGw7XG4gICAgICAgIHRoaXMuYmJfcG9zID0gMDtcbiAgICB9XG4gICAgX19pbml0KGksIGJiKSB7XG4gICAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGdldFJvb3RBc1ZhcmlhYmxlV2l0aFZhbHVlcyhiYiwgb2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqIHx8IG5ldyBWYXJpYWJsZVdpdGhWYWx1ZXMoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhcmlhYmxlV2l0aFZhbHVlcyhiYiwgb2JqKSB7XG4gICAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFyaWFibGVXaXRoVmFsdWVzKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuICAgIHZhcmlhYmxlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZFVpbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IHZhcmlhYmxlX2pzXzEuVmFyaWFibGUudW5kZWZpbmVkO1xuICAgIH1cbiAgICB1bml0KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZFVpbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IHVuaXRfanNfMS5Vbml0LnVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkRmxvYXQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwLjA7XG4gICAgfVxuICAgIHZhbHVlcyhpbmRleCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuICAgIHZhbHVlc0xlbmd0aCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG4gICAgdmFsdWVzQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlciwgdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6IG51bGw7XG4gICAgfVxuICAgIHZhbHVlc0ludDY0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KSA6IEJpZ0ludCgwKTtcbiAgICB9XG4gICAgdmFsdWVzSW50NjRMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuICAgIGFsdGl0dWRlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQxNih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbiAgICBhZ2dyZWdhdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkVWludDgodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogYWdncmVnYXRpb25fanNfMS5BZ2dyZWdhdGlvbi5ub25lO1xuICAgIH1cbiAgICBwcmVzc3VyZUxldmVsKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQxNih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbiAgICBkZXB0aCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkSW50MTYodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG4gICAgZGVwdGhUbygpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMjIpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkSW50MTYodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG4gICAgZW5zZW1ibGVNZW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDE2KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuICAgIHByZXZpb3VzRGF5KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQxNih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVXaXRoVmFsdWVzID0gVmFyaWFibGVXaXRoVmFsdWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSB0aGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIsIGRvIG5vdCBtb2RpZnlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFyaWFibGUgPSB2b2lkIDA7XG52YXIgVmFyaWFibGU7XG4oZnVuY3Rpb24gKFZhcmlhYmxlKSB7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1bmRlZmluZWRcIl0gPSAwXSA9IFwidW5kZWZpbmVkXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJhcHBhcmVudF90ZW1wZXJhdHVyZVwiXSA9IDFdID0gXCJhcHBhcmVudF90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiY2FwZVwiXSA9IDJdID0gXCJjYXBlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjbG91ZF9jb3ZlclwiXSA9IDNdID0gXCJjbG91ZF9jb3ZlclwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiY2xvdWRfY292ZXJfaGlnaFwiXSA9IDRdID0gXCJjbG91ZF9jb3Zlcl9oaWdoXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjbG91ZF9jb3Zlcl9sb3dcIl0gPSA1XSA9IFwiY2xvdWRfY292ZXJfbG93XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjbG91ZF9jb3Zlcl9taWRcIl0gPSA2XSA9IFwiY2xvdWRfY292ZXJfbWlkXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJkYXlsaWdodF9kdXJhdGlvblwiXSA9IDddID0gXCJkYXlsaWdodF9kdXJhdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZGV3X3BvaW50XCJdID0gOF0gPSBcImRld19wb2ludFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZGlmZnVzZV9yYWRpYXRpb25cIl0gPSA5XSA9IFwiZGlmZnVzZV9yYWRpYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpZmZ1c2VfcmFkaWF0aW9uX2luc3RhbnRcIl0gPSAxMF0gPSBcImRpZmZ1c2VfcmFkaWF0aW9uX2luc3RhbnRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpcmVjdF9ub3JtYWxfaXJyYWRpYW5jZVwiXSA9IDExXSA9IFwiZGlyZWN0X25vcm1hbF9pcnJhZGlhbmNlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJkaXJlY3Rfbm9ybWFsX2lycmFkaWFuY2VfaW5zdGFudFwiXSA9IDEyXSA9IFwiZGlyZWN0X25vcm1hbF9pcnJhZGlhbmNlX2luc3RhbnRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpcmVjdF9yYWRpYXRpb25cIl0gPSAxM10gPSBcImRpcmVjdF9yYWRpYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpcmVjdF9yYWRpYXRpb25faW5zdGFudFwiXSA9IDE0XSA9IFwiZGlyZWN0X3JhZGlhdGlvbl9pbnN0YW50XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJldDBfZmFvX2V2YXBvdHJhbnNwaXJhdGlvblwiXSA9IDE1XSA9IFwiZXQwX2Zhb19ldmFwb3RyYW5zcGlyYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImV2YXBvdHJhbnNwaXJhdGlvblwiXSA9IDE2XSA9IFwiZXZhcG90cmFuc3BpcmF0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJmcmVlemluZ19sZXZlbF9oZWlnaHRcIl0gPSAxN10gPSBcImZyZWV6aW5nX2xldmVsX2hlaWdodFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZ3Jvd2luZ19kZWdyZWVfZGF5c1wiXSA9IDE4XSA9IFwiZ3Jvd2luZ19kZWdyZWVfZGF5c1wiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiaXNfZGF5XCJdID0gMTldID0gXCJpc19kYXlcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImxhdGVudF9oZWF0X2ZsdXhcIl0gPSAyMF0gPSBcImxhdGVudF9oZWF0X2ZsdXhcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImxlYWZfd2V0bmVzc19wcm9iYWJpbGl0eVwiXSA9IDIxXSA9IFwibGVhZl93ZXRuZXNzX3Byb2JhYmlsaXR5XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJsaWZ0ZWRfaW5kZXhcIl0gPSAyMl0gPSBcImxpZnRlZF9pbmRleFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wibGlnaHRuaW5nX3BvdGVudGlhbFwiXSA9IDIzXSA9IFwibGlnaHRuaW5nX3BvdGVudGlhbFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlY2lwaXRhdGlvblwiXSA9IDI0XSA9IFwicHJlY2lwaXRhdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlY2lwaXRhdGlvbl9ob3Vyc1wiXSA9IDI1XSA9IFwicHJlY2lwaXRhdGlvbl9ob3Vyc1wiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlY2lwaXRhdGlvbl9wcm9iYWJpbGl0eVwiXSA9IDI2XSA9IFwicHJlY2lwaXRhdGlvbl9wcm9iYWJpbGl0eVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlc3N1cmVfbXNsXCJdID0gMjddID0gXCJwcmVzc3VyZV9tc2xcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInJhaW5cIl0gPSAyOF0gPSBcInJhaW5cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInJlbGF0aXZlX2h1bWlkaXR5XCJdID0gMjldID0gXCJyZWxhdGl2ZV9odW1pZGl0eVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicnVub2ZmXCJdID0gMzBdID0gXCJydW5vZmZcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInNlbnNpYmxlX2hlYXRfZmx1eFwiXSA9IDMxXSA9IFwic2Vuc2libGVfaGVhdF9mbHV4XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzaG9ydHdhdmVfcmFkaWF0aW9uXCJdID0gMzJdID0gXCJzaG9ydHdhdmVfcmFkaWF0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzaG9ydHdhdmVfcmFkaWF0aW9uX2luc3RhbnRcIl0gPSAzM10gPSBcInNob3J0d2F2ZV9yYWRpYXRpb25faW5zdGFudFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic2hvd2Vyc1wiXSA9IDM0XSA9IFwic2hvd2Vyc1wiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic25vd19kZXB0aFwiXSA9IDM1XSA9IFwic25vd19kZXB0aFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic25vd19oZWlnaHRcIl0gPSAzNl0gPSBcInNub3dfaGVpZ2h0XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzbm93ZmFsbFwiXSA9IDM3XSA9IFwic25vd2ZhbGxcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInNub3dmYWxsX2hlaWdodFwiXSA9IDM4XSA9IFwic25vd2ZhbGxfaGVpZ2h0XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzbm93ZmFsbF93YXRlcl9lcXVpdmFsZW50XCJdID0gMzldID0gXCJzbm93ZmFsbF93YXRlcl9lcXVpdmFsZW50XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzdW5yaXNlXCJdID0gNDBdID0gXCJzdW5yaXNlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzdW5zZXRcIl0gPSA0MV0gPSBcInN1bnNldFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic29pbF9tb2lzdHVyZVwiXSA9IDQyXSA9IFwic29pbF9tb2lzdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic29pbF9tb2lzdHVyZV9pbmRleFwiXSA9IDQzXSA9IFwic29pbF9tb2lzdHVyZV9pbmRleFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic29pbF90ZW1wZXJhdHVyZVwiXSA9IDQ0XSA9IFwic29pbF90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3VyZmFjZV9wcmVzc3VyZVwiXSA9IDQ1XSA9IFwic3VyZmFjZV9wcmVzc3VyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3VyZmFjZV90ZW1wZXJhdHVyZVwiXSA9IDQ2XSA9IFwic3VyZmFjZV90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widGVtcGVyYXR1cmVcIl0gPSA0N10gPSBcInRlbXBlcmF0dXJlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ0ZXJyZXN0cmlhbF9yYWRpYXRpb25cIl0gPSA0OF0gPSBcInRlcnJlc3RyaWFsX3JhZGlhdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widGVycmVzdHJpYWxfcmFkaWF0aW9uX2luc3RhbnRcIl0gPSA0OV0gPSBcInRlcnJlc3RyaWFsX3JhZGlhdGlvbl9pbnN0YW50XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ0b3RhbF9jb2x1bW5faW50ZWdyYXRlZF93YXRlcl92YXBvdXJcIl0gPSA1MF0gPSBcInRvdGFsX2NvbHVtbl9pbnRlZ3JhdGVkX3dhdGVyX3ZhcG91clwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXBkcmFmdFwiXSA9IDUxXSA9IFwidXBkcmFmdFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXZfaW5kZXhcIl0gPSA1Ml0gPSBcInV2X2luZGV4XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1dl9pbmRleF9jbGVhcl9za3lcIl0gPSA1M10gPSBcInV2X2luZGV4X2NsZWFyX3NreVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widmFwb3VyX3ByZXNzdXJlX2RlZmljaXRcIl0gPSA1NF0gPSBcInZhcG91cl9wcmVzc3VyZV9kZWZpY2l0XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ2aXNpYmlsaXR5XCJdID0gNTVdID0gXCJ2aXNpYmlsaXR5XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3ZWF0aGVyX2NvZGVcIl0gPSA1Nl0gPSBcIndlYXRoZXJfY29kZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wid2luZF9kaXJlY3Rpb25cIl0gPSA1N10gPSBcIndpbmRfZGlyZWN0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3aW5kX2d1c3RzXCJdID0gNThdID0gXCJ3aW5kX2d1c3RzXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3aW5kX3NwZWVkXCJdID0gNTldID0gXCJ3aW5kX3NwZWVkXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ2ZXJ0aWNhbF92ZWxvY2l0eVwiXSA9IDYwXSA9IFwidmVydGljYWxfdmVsb2NpdHlcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImdlb3BvdGVudGlhbF9oZWlnaHRcIl0gPSA2MV0gPSBcImdlb3BvdGVudGlhbF9oZWlnaHRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndldF9idWxiX3RlbXBlcmF0dXJlXCJdID0gNjJdID0gXCJ3ZXRfYnVsYl90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicml2ZXJfZGlzY2hhcmdlXCJdID0gNjNdID0gXCJyaXZlcl9kaXNjaGFyZ2VcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndhdmVfaGVpZ2h0XCJdID0gNjRdID0gXCJ3YXZlX2hlaWdodFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wid2F2ZV9wZXJpb2RcIl0gPSA2NV0gPSBcIndhdmVfcGVyaW9kXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3YXZlX2RpcmVjdGlvblwiXSA9IDY2XSA9IFwid2F2ZV9kaXJlY3Rpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndpbmRfd2F2ZV9oZWlnaHRcIl0gPSA2N10gPSBcIndpbmRfd2F2ZV9oZWlnaHRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndpbmRfd2F2ZV9wZXJpb2RcIl0gPSA2OF0gPSBcIndpbmRfd2F2ZV9wZXJpb2RcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndpbmRfd2F2ZV9wZWFrX3BlcmlvZFwiXSA9IDY5XSA9IFwid2luZF93YXZlX3BlYWtfcGVyaW9kXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3aW5kX3dhdmVfZGlyZWN0aW9uXCJdID0gNzBdID0gXCJ3aW5kX3dhdmVfZGlyZWN0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzd2VsbF93YXZlX2hlaWdodFwiXSA9IDcxXSA9IFwic3dlbGxfd2F2ZV9oZWlnaHRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInN3ZWxsX3dhdmVfcGVyaW9kXCJdID0gNzJdID0gXCJzd2VsbF93YXZlX3BlcmlvZFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3dlbGxfd2F2ZV9wZWFrX3BlcmlvZFwiXSA9IDczXSA9IFwic3dlbGxfd2F2ZV9wZWFrX3BlcmlvZFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3dlbGxfd2F2ZV9kaXJlY3Rpb25cIl0gPSA3NF0gPSBcInN3ZWxsX3dhdmVfZGlyZWN0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJwbTEwXCJdID0gNzVdID0gXCJwbTEwXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJwbTJwNVwiXSA9IDc2XSA9IFwicG0ycDVcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImR1c3RcIl0gPSA3N10gPSBcImR1c3RcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImFlcm9zb2xfb3B0aWNhbF9kZXB0aFwiXSA9IDc4XSA9IFwiYWVyb3NvbF9vcHRpY2FsX2RlcHRoXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjYXJib25fbW9ub3hpZGVcIl0gPSA3OV0gPSBcImNhcmJvbl9tb25veGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wibml0cm9nZW5fZGlveGlkZVwiXSA9IDgwXSA9IFwibml0cm9nZW5fZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiYW1tb25pYVwiXSA9IDgxXSA9IFwiYW1tb25pYVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wib3pvbmVcIl0gPSA4Ml0gPSBcIm96b25lXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzdWxwaHVyX2Rpb3hpZGVcIl0gPSA4M10gPSBcInN1bHBodXJfZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiYWxkZXJfcG9sbGVuXCJdID0gODRdID0gXCJhbGRlcl9wb2xsZW5cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImJpcmNoX3BvbGxlblwiXSA9IDg1XSA9IFwiYmlyY2hfcG9sbGVuXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJncmFzc19wb2xsZW5cIl0gPSA4Nl0gPSBcImdyYXNzX3BvbGxlblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wibXVnd29ydF9wb2xsZW5cIl0gPSA4N10gPSBcIm11Z3dvcnRfcG9sbGVuXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJvbGl2ZV9wb2xsZW5cIl0gPSA4OF0gPSBcIm9saXZlX3BvbGxlblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicmFnd2VlZF9wb2xsZW5cIl0gPSA4OV0gPSBcInJhZ3dlZWRfcG9sbGVuXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJldXJvcGVhbl9hcWlcIl0gPSA5MF0gPSBcImV1cm9wZWFuX2FxaVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZXVyb3BlYW5fYXFpX3BtMnA1XCJdID0gOTFdID0gXCJldXJvcGVhbl9hcWlfcG0ycDVcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImV1cm9wZWFuX2FxaV9wbTEwXCJdID0gOTJdID0gXCJldXJvcGVhbl9hcWlfcG0xMFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZXVyb3BlYW5fYXFpX25pdHJvZ2VuX2Rpb3hpZGVcIl0gPSA5M10gPSBcImV1cm9wZWFuX2FxaV9uaXRyb2dlbl9kaW94aWRlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJldXJvcGVhbl9hcWlfb3pvbmVcIl0gPSA5NF0gPSBcImV1cm9wZWFuX2FxaV9vem9uZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZXVyb3BlYW5fYXFpX3N1bHBodXJfZGlveGlkZVwiXSA9IDk1XSA9IFwiZXVyb3BlYW5fYXFpX3N1bHBodXJfZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXNfYXFpXCJdID0gOTZdID0gXCJ1c19hcWlcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInVzX2FxaV9wbTJwNVwiXSA9IDk3XSA9IFwidXNfYXFpX3BtMnA1XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1c19hcWlfcG0xMFwiXSA9IDk4XSA9IFwidXNfYXFpX3BtMTBcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInVzX2FxaV9uaXRyb2dlbl9kaW94aWRlXCJdID0gOTldID0gXCJ1c19hcWlfbml0cm9nZW5fZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXNfYXFpX296b25lXCJdID0gMTAwXSA9IFwidXNfYXFpX296b25lXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1c19hcWlfc3VscGh1cl9kaW94aWRlXCJdID0gMTAxXSA9IFwidXNfYXFpX3N1bHBodXJfZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXNfYXFpX2NhcmJvbl9tb25veGlkZVwiXSA9IDEwMl0gPSBcInVzX2FxaV9jYXJib25fbW9ub3hpZGVcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInN1bnNoaW5lX2R1cmF0aW9uXCJdID0gMTAzXSA9IFwic3Vuc2hpbmVfZHVyYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImNvbnZlY3RpdmVfaW5oaWJpdGlvblwiXSA9IDEwNF0gPSBcImNvbnZlY3RpdmVfaW5oaWJpdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic2hvcnR3YXZlX3JhZGlhdGlvbl9jbGVhcl9za3lcIl0gPSAxMDVdID0gXCJzaG9ydHdhdmVfcmFkaWF0aW9uX2NsZWFyX3NreVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZ2xvYmFsX3RpbHRlZF9pcnJhZGlhbmNlXCJdID0gMTA2XSA9IFwiZ2xvYmFsX3RpbHRlZF9pcnJhZGlhbmNlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJnbG9iYWxfdGlsdGVkX2lycmFkaWFuY2VfaW5zdGFudFwiXSA9IDEwN10gPSBcImdsb2JhbF90aWx0ZWRfaXJyYWRpYW5jZV9pbnN0YW50XCI7XG59KShWYXJpYWJsZSB8fCAoZXhwb3J0cy5WYXJpYWJsZSA9IFZhcmlhYmxlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyLCBkbyBub3QgbW9kaWZ5XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFyaWFibGVzV2l0aFRpbWUgPSB2b2lkIDA7XG5jb25zdCBmbGF0YnVmZmVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZmxhdGJ1ZmZlcnNcIikpO1xuY29uc3QgdmFyaWFibGVfd2l0aF92YWx1ZXNfanNfMSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlLXdpdGgtdmFsdWVzLmpzXCIpO1xuY2xhc3MgVmFyaWFibGVzV2l0aFRpbWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJiID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYl9wb3MgPSAwO1xuICAgIH1cbiAgICBfX2luaXQoaSwgYmIpIHtcbiAgICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgICB0aGlzLmJiID0gYmI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVmFyaWFibGVzV2l0aFRpbWUoYmIsIG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFyaWFibGVzV2l0aFRpbWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhcmlhYmxlc1dpdGhUaW1lKGJiLCBvYmopIHtcbiAgICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICAgIHJldHVybiAob2JqIHx8IG5ldyBWYXJpYWJsZXNXaXRoVGltZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cbiAgICB0aW1lKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IEJpZ0ludCgnMCcpO1xuICAgIH1cbiAgICB0aW1lRW5kKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IEJpZ0ludCgnMCcpO1xuICAgIH1cbiAgICBpbnRlcnZhbCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbiAgICB2YXJpYWJsZXMoaW5kZXgsIG9iaikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyB2YXJpYWJsZV93aXRoX3ZhbHVlc19qc18xLlZhcmlhYmxlV2l0aFZhbHVlcygpKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYikgOiBudWxsO1xuICAgIH1cbiAgICB2YXJpYWJsZXNMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZXNXaXRoVGltZSA9IFZhcmlhYmxlc1dpdGhUaW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSB0aGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIsIGRvIG5vdCBtb2RpZnlcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWF0aGVyQXBpUmVzcG9uc2UgPSB2b2lkIDA7XG5jb25zdCBmbGF0YnVmZmVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZmxhdGJ1ZmZlcnNcIikpO1xuY29uc3QgbW9kZWxfanNfMSA9IHJlcXVpcmUoXCIuL21vZGVsLmpzXCIpO1xuY29uc3QgdmFyaWFibGVzX3dpdGhfdGltZV9qc18xID0gcmVxdWlyZShcIi4vdmFyaWFibGVzLXdpdGgtdGltZS5qc1wiKTtcbmNsYXNzIFdlYXRoZXJBcGlSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmIgPSBudWxsO1xuICAgICAgICB0aGlzLmJiX3BvcyA9IDA7XG4gICAgfVxuICAgIF9faW5pdChpLCBiYikge1xuICAgICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRSb290QXNXZWF0aGVyQXBpUmVzcG9uc2UoYmIsIG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiB8fCBuZXcgV2VhdGhlckFwaVJlc3BvbnNlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNXZWF0aGVyQXBpUmVzcG9uc2UoYmIsIG9iaikge1xuICAgICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFdlYXRoZXJBcGlSZXNwb25zZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cbiAgICBsYXRpdHVkZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDAuMDtcbiAgICB9XG4gICAgbG9uZ2l0dWRlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMC4wO1xuICAgIH1cbiAgICBlbGV2YXRpb24oKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkRmxvYXQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwLjA7XG4gICAgfVxuICAgIGdlbmVyYXRpb25UaW1lTWlsbGlzZWNvbmRzKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDAuMDtcbiAgICB9XG4gICAgbG9jYXRpb25JZCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogQmlnSW50KCcwJyk7XG4gICAgfVxuICAgIG1vZGVsKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiBtb2RlbF9qc18xLk1vZGVsLnVuZGVmaW5lZDtcbiAgICB9XG4gICAgdXRjT2Zmc2V0U2Vjb25kcygpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG4gICAgdGltZXpvbmUob3B0aW9uYWxFbmNvZGluZykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuICAgIHRpbWV6b25lQWJicmV2aWF0aW9uKG9wdGlvbmFsRW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50KG9iaikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyB2YXJpYWJsZXNfd2l0aF90aW1lX2pzXzEuVmFyaWFibGVzV2l0aFRpbWUoKSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIpIDogbnVsbDtcbiAgICB9XG4gICAgZGFpbHkob2JqKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IHZhcmlhYmxlc193aXRoX3RpbWVfanNfMS5WYXJpYWJsZXNXaXRoVGltZSgpKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYikgOiBudWxsO1xuICAgIH1cbiAgICBob3VybHkob2JqKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IHZhcmlhYmxlc193aXRoX3RpbWVfanNfMS5WYXJpYWJsZXNXaXRoVGltZSgpKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYikgOiBudWxsO1xuICAgIH1cbiAgICBtaW51dGVseTE1KG9iaikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyB2YXJpYWJsZXNfd2l0aF90aW1lX2pzXzEuVmFyaWFibGVzV2l0aFRpbWUoKSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIpIDogbnVsbDtcbiAgICB9XG4gICAgc2l4SG91cmx5KG9iaikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAzMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyB2YXJpYWJsZXNfd2l0aF90aW1lX2pzXzEuVmFyaWFibGVzV2l0aFRpbWUoKSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIpIDogbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLldlYXRoZXJBcGlSZXNwb25zZSA9IFdlYXRoZXJBcGlSZXNwb25zZTtcbiIsImltcG9ydCB7IEJ5dGVCdWZmZXIgfSBmcm9tIFwiLi9ieXRlLWJ1ZmZlci5qc1wiO1xuaW1wb3J0IHsgU0laRU9GX1NIT1JULCBTSVpFX1BSRUZJWF9MRU5HVEgsIFNJWkVPRl9JTlQsIEZJTEVfSURFTlRJRklFUl9MRU5HVEggfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmV4cG9ydCBjbGFzcyBCdWlsZGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBGbGF0QnVmZmVyQnVpbGRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRfaW5pdGlhbF9zaXplKSB7XG4gICAgICAgIC8qKiBNaW5pbXVtIGFsaWdubWVudCBlbmNvdW50ZXJlZCBzbyBmYXIuICovXG4gICAgICAgIHRoaXMubWluYWxpZ24gPSAxO1xuICAgICAgICAvKiogVGhlIHZ0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdGFibGUuICovXG4gICAgICAgIHRoaXMudnRhYmxlID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBhbW91bnQgb2YgZmllbGRzIHdlJ3JlIGFjdHVhbGx5IHVzaW5nLiAqL1xuICAgICAgICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuICAgICAgICAvKiogV2hldGhlciB3ZSBhcmUgY3VycmVudGx5IHNlcmlhbGl6aW5nIGEgdGFibGUuICovXG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFN0YXJ0aW5nIG9mZnNldCBvZiB0aGUgY3VycmVudCBzdHJ1Y3QvdGFibGUuICovXG4gICAgICAgIHRoaXMub2JqZWN0X3N0YXJ0ID0gMDtcbiAgICAgICAgLyoqIExpc3Qgb2Ygb2Zmc2V0cyBvZiBhbGwgdnRhYmxlcy4gKi9cbiAgICAgICAgdGhpcy52dGFibGVzID0gW107XG4gICAgICAgIC8qKiBGb3IgdGhlIGN1cnJlbnQgdmVjdG9yIGJlaW5nIGJ1aWx0LiAqL1xuICAgICAgICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSAwO1xuICAgICAgICAvKiogRmFsc2Ugb21pdHMgZGVmYXVsdCB2YWx1ZXMgZnJvbSB0aGUgc2VyaWFsaXplZCBkYXRhICovXG4gICAgICAgIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdHJpbmdfbWFwcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dF9lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGxldCBpbml0aWFsX3NpemU7XG4gICAgICAgIGlmICghb3B0X2luaXRpYWxfc2l6ZSkge1xuICAgICAgICAgICAgaW5pdGlhbF9zaXplID0gMTAyNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluaXRpYWxfc2l6ZSA9IG9wdF9pbml0aWFsX3NpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtCeXRlQnVmZmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYiA9IEJ5dGVCdWZmZXIuYWxsb2NhdGUoaW5pdGlhbF9zaXplKTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IGluaXRpYWxfc2l6ZTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuYmIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcbiAgICAgICAgdGhpcy5taW5hbGlnbiA9IDE7XG4gICAgICAgIHRoaXMudnRhYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcbiAgICAgICAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9iamVjdF9zdGFydCA9IDA7XG4gICAgICAgIHRoaXMudnRhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSAwO1xuICAgICAgICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyaW5nX21hcHMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBzYXZlIHNwYWNlLCBmaWVsZHMgdGhhdCBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBkb24ndCBnZXQgc2VyaWFsaXplZCBpbnRvIHRoZSBidWZmZXIuIEZvcmNpbmcgZGVmYXVsdHMgcHJvdmlkZXMgYVxuICAgICAqIHdheSB0byBtYW51YWxseSBkaXNhYmxlIHRoaXMgb3B0aW1pemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRGVmYXVsdHMgdHJ1ZSBhbHdheXMgc2VyaWFsaXplcyBkZWZhdWx0IHZhbHVlc1xuICAgICAqL1xuICAgIGZvcmNlRGVmYXVsdHMoZm9yY2VEZWZhdWx0cykge1xuICAgICAgICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZm9yY2VEZWZhdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBCeXRlQnVmZmVyIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gICAgICogY2FsbGVkIGZpbmlzaCgpLiBUaGUgYWN0dWFsIGRhdGEgc3RhcnRzIGF0IHRoZSBCeXRlQnVmZmVyJ3MgY3VycmVudCBwb3NpdGlvbixcbiAgICAgKiBub3QgbmVjZXNzYXJpbHkgYXQgMC5cbiAgICAgKi9cbiAgICBkYXRhQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlcyByZXByZXNlbnRpbmcgdGhlIEZsYXRCdWZmZXIuIE9ubHkgY2FsbCB0aGlzIGFmdGVyIHlvdSd2ZVxuICAgICAqIGNhbGxlZCBmaW5pc2goKS5cbiAgICAgKi9cbiAgICBhc1VpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJiLmJ5dGVzKCkuc3ViYXJyYXkodGhpcy5iYi5wb3NpdGlvbigpLCB0aGlzLmJiLnBvc2l0aW9uKCkgKyB0aGlzLm9mZnNldCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0byB3cml0ZSBhbiBlbGVtZW50IG9mIGBzaXplYCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2AgaGF2ZSBiZWVuXG4gICAgICogd3JpdHRlbiwgZS5nLiBpZiB5b3Ugd3JpdGUgYSBzdHJpbmcsIHlvdSBuZWVkIHRvIGFsaWduIHN1Y2ggdGhlIGludCBsZW5ndGhcbiAgICAgKiBmaWVsZCBpcyBhbGlnbmVkIHRvIDQgYnl0ZXMsIGFuZCB0aGUgc3RyaW5nIGRhdGEgZm9sbG93cyBpdCBkaXJlY3RseS4gSWYgYWxsXG4gICAgICogeW91IG5lZWQgdG8gZG8gaXMgYWxpZ25tZW50LCBgYWRkaXRpb25hbF9ieXRlc2Agd2lsbCBiZSAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpemUgVGhpcyBpcyB0aGUgb2YgdGhlIG5ldyBlbGVtZW50IHRvIHdyaXRlXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxfYnl0ZXMgVGhlIHBhZGRpbmcgc2l6ZVxuICAgICAqL1xuICAgIHByZXAoc2l6ZSwgYWRkaXRpb25hbF9ieXRlcykge1xuICAgICAgICAvLyBUcmFjayB0aGUgYmlnZ2VzdCB0aGluZyB3ZSd2ZSBldmVyIGFsaWduZWQgdG8uXG4gICAgICAgIGlmIChzaXplID4gdGhpcy5taW5hbGlnbikge1xuICAgICAgICAgICAgdGhpcy5taW5hbGlnbiA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYW1vdW50IG9mIGFsaWdubWVudCBuZWVkZWQgc3VjaCB0aGF0IGBzaXplYCBpcyBwcm9wZXJseVxuICAgICAgICAvLyBhbGlnbmVkIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYFxuICAgICAgICBjb25zdCBhbGlnbl9zaXplID0gKCh+KHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2UgKyBhZGRpdGlvbmFsX2J5dGVzKSkgKyAxKSAmIChzaXplIC0gMSk7XG4gICAgICAgIC8vIFJlYWxsb2NhdGUgdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gICAgICAgIHdoaWxlICh0aGlzLnNwYWNlIDwgYWxpZ25fc2l6ZSArIHNpemUgKyBhZGRpdGlvbmFsX2J5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRfYnVmX3NpemUgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gICAgICAgICAgICB0aGlzLmJiID0gQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2UgKz0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gb2xkX2J1Zl9zaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFkKGFsaWduX3NpemUpO1xuICAgIH1cbiAgICBwYWQoYnl0ZV9zaXplKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZV9zaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQ4KC0tdGhpcy5zcGFjZSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVJbnQ4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmIud3JpdGVJbnQ4KHRoaXMuc3BhY2UgLT0gMSwgdmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUludDE2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmIud3JpdGVJbnQxNih0aGlzLnNwYWNlIC09IDIsIHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbnQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlSW50NjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUZsb2F0MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYi53cml0ZUZsb2F0MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlRmxvYXQ2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGBpbnQ4YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBpbnQ4YCB0byBhZGQgdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhZGRJbnQ4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJlcCgxLCAwKTtcbiAgICAgICAgdGhpcy53cml0ZUludDgodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYGludDE2YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBpbnQxNmAgdG8gYWRkIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgYWRkSW50MTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVwKDIsIDApO1xuICAgICAgICB0aGlzLndyaXRlSW50MTYodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYGludDMyYCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBpbnQzMmAgdG8gYWRkIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgYWRkSW50MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVwKDQsIDApO1xuICAgICAgICB0aGlzLndyaXRlSW50MzIodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYGludDY0YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBpbnQ2NGAgdG8gYWRkIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgYWRkSW50NjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVwKDgsIDApO1xuICAgICAgICB0aGlzLndyaXRlSW50NjQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBgZmxvYXQzMmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgZmxvYXQzMmAgdG8gYWRkIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgYWRkRmxvYXQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZXAoNCwgMCk7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDMyKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgYGZsb2F0NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGZsb2F0NjRgIHRvIGFkZCB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFkZEZsb2F0NjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVwKDgsIDApO1xuICAgICAgICB0aGlzLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XG4gICAgfVxuICAgIGFkZEZpZWxkSW50OCh2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRJbnQ4KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRGaWVsZEludDE2KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEludDE2KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRGaWVsZEludDMyKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEludDMyKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRGaWVsZEludDY0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRJbnQ2NCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmllbGRGbG9hdDMyKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZsb2F0MzIodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEZpZWxkRmxvYXQ2NCh2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRGbG9hdDY0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRGaWVsZE9mZnNldCh2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRPZmZzZXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cnVjdHMgYXJlIHN0b3JlZCBpbmxpbmUsIHNvIG5vdGhpbmcgYWRkaXRpb25hbCBpcyBiZWluZyBhZGRlZC4gYGRgIGlzIGFsd2F5cyAwLlxuICAgICAqL1xuICAgIGFkZEZpZWxkU3RydWN0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5uZXN0ZWQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cnVjdHVyZXMgYXJlIGFsd2F5cyBzdG9yZWQgaW5saW5lLCB0aGV5IG5lZWQgdG8gYmUgY3JlYXRlZCByaWdodFxuICAgICAqIHdoZXJlIHRoZXkncmUgdXNlZC4gIFlvdSdsbCBnZXQgdGhpcyBhc3NlcnRpb24gZmFpbHVyZSBpZiB5b3VcbiAgICAgKiBjcmVhdGVkIGl0IGVsc2V3aGVyZS5cbiAgICAgKi9cbiAgICBuZXN0ZWQob2JqKSB7XG4gICAgICAgIGlmIChvYmogIT0gdGhpcy5vZmZzZXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmxhdEJ1ZmZlcnM6IHN0cnVjdCBtdXN0IGJlIHNlcmlhbGl6ZWQgaW5saW5lLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3VsZCBub3QgYmUgY3JlYXRpbmcgYW55IG90aGVyIG9iamVjdCwgc3RyaW5nIG9yIHZlY3RvclxuICAgICAqIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBjb25zdHJ1Y3RlZFxuICAgICAqL1xuICAgIG5vdE5lc3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZXN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZsYXRCdWZmZXJzOiBvYmplY3Qgc2VyaWFsaXphdGlvbiBtdXN0IG5vdCBiZSBuZXN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHZ0YWJsZSBhdCBgdm9mZnNldGAgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBzbG90KHZvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMudnRhYmxlICE9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy52dGFibGVbdm9mZnNldF0gPSB0aGlzLm9mZnNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvdWJsZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgQnl0ZUJ1ZmZlciBhbmQgY29waWVzIHRoZSBvbGQgZGF0YSB0b3dhcmRzXG4gICAgICogdGhlIGVuZCBvZiB0aGUgbmV3IGJ1ZmZlciAoc2luY2Ugd2UgYnVpbGQgdGhlIGJ1ZmZlciBiYWNrd2FyZHMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJiIFRoZSBjdXJyZW50IGJ1ZmZlciB3aXRoIHRoZSBleGlzdGluZyBkYXRhXG4gICAgICogQHJldHVybnMgQSBuZXcgYnl0ZSBidWZmZXIgd2l0aCB0aGUgb2xkIGRhdGEgY29waWVkXG4gICAgICogdG8gaXQuIFRoZSBkYXRhIGlzIGxvY2F0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxuICAgICAqXG4gICAgICogdWludDhBcnJheS5zZXQoKSBmb3JtYWxseSB0YWtlcyB7QXJyYXk8bnVtYmVyPnxBcnJheUJ1ZmZlclZpZXd9LCBzbyB0byBwYXNzXG4gICAgICogaXQgYSB1aW50OEFycmF5IHdlIG5lZWQgdG8gc3VwcHJlc3MgdGhlIHR5cGUgY2hlY2s6XG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgICAqL1xuICAgIHN0YXRpYyBncm93Qnl0ZUJ1ZmZlcihiYikge1xuICAgICAgICBjb25zdCBvbGRfYnVmX3NpemUgPSBiYi5jYXBhY2l0eSgpO1xuICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ3JvdyBiZXlvbmQgd2hhdCBmaXRzIGluIGFuIGludC5cbiAgICAgICAgaWYgKG9sZF9idWZfc2l6ZSAmIDB4QzAwMDAwMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3X2J1Zl9zaXplID0gb2xkX2J1Zl9zaXplIDw8IDE7XG4gICAgICAgIGNvbnN0IG5iYiA9IEJ5dGVCdWZmZXIuYWxsb2NhdGUobmV3X2J1Zl9zaXplKTtcbiAgICAgICAgbmJiLnNldFBvc2l0aW9uKG5ld19idWZfc2l6ZSAtIG9sZF9idWZfc2l6ZSk7XG4gICAgICAgIG5iYi5ieXRlcygpLnNldChiYi5ieXRlcygpLCBuZXdfYnVmX3NpemUgLSBvbGRfYnVmX3NpemUpO1xuICAgICAgICByZXR1cm4gbmJiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uIG9mZnNldCwgcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2lsbCBiZSB3cml0dGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucHJlcChTSVpFT0ZfSU5ULCAwKTsgLy8gRW5zdXJlIGFsaWdubWVudCBpcyBhbHJlYWR5IGRvbmUuXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpIC0gb2Zmc2V0ICsgU0laRU9GX0lOVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGVuY29kaW5nIGEgbmV3IG9iamVjdCBpbiB0aGUgYnVmZmVyLiAgVXNlcnMgd2lsbCBub3QgdXN1YWxseSBuZWVkIHRvXG4gICAgICogY2FsbCB0aGlzIGRpcmVjdGx5LiBUaGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIgd2lsbCBnZW5lcmF0ZSBoZWxwZXIgbWV0aG9kc1xuICAgICAqIHRoYXQgY2FsbCB0aGlzIG1ldGhvZCBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIHN0YXJ0T2JqZWN0KG51bWZpZWxkcykge1xuICAgICAgICB0aGlzLm5vdE5lc3RlZCgpO1xuICAgICAgICBpZiAodGhpcy52dGFibGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52dGFibGUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZ0YWJsZV9pbl91c2UgPSBudW1maWVsZHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtZmllbGRzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudnRhYmxlW2ldID0gMDsgLy8gVGhpcyB3aWxsIHB1c2ggYWRkaXRpb25hbCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTmVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYmplY3Rfc3RhcnQgPSB0aGlzLm9mZnNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggb2ZmIHdyaXRpbmcgdGhlIG9iamVjdCB0aGF0IGlzIHVuZGVyIGNvbnN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvZmZzZXQgdG8gdGhlIG9iamVjdCBpbnNpZGUgYGRhdGFCdWZmZXJgXG4gICAgICovXG4gICAgZW5kT2JqZWN0KCkge1xuICAgICAgICBpZiAodGhpcy52dGFibGUgPT0gbnVsbCB8fCAhdGhpcy5pc05lc3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRJbnQzMigwKTtcbiAgICAgICAgY29uc3QgdnRhYmxlbG9jID0gdGhpcy5vZmZzZXQoKTtcbiAgICAgICAgLy8gVHJpbSB0cmFpbGluZyB6ZXJvZXMuXG4gICAgICAgIGxldCBpID0gdGhpcy52dGFibGVfaW5fdXNlIC0gMTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIGZvciAoOyBpID49IDAgJiYgdGhpcy52dGFibGVbaV0gPT0gMDsgaS0tKSB7IH1cbiAgICAgICAgY29uc3QgdHJpbW1lZF9zaXplID0gaSArIDE7XG4gICAgICAgIC8vIFdyaXRlIG91dCB0aGUgY3VycmVudCB2dGFibGUuXG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLy8gT2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUuXG4gICAgICAgICAgICB0aGlzLmFkZEludDE2KHRoaXMudnRhYmxlW2ldICE9IDAgPyB2dGFibGVsb2MgLSB0aGlzLnZ0YWJsZVtpXSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkX2ZpZWxkcyA9IDI7IC8vIFRoZSBmaWVsZHMgYmVsb3c6XG4gICAgICAgIHRoaXMuYWRkSW50MTYodnRhYmxlbG9jIC0gdGhpcy5vYmplY3Rfc3RhcnQpO1xuICAgICAgICBjb25zdCBsZW4gPSAodHJpbW1lZF9zaXplICsgc3RhbmRhcmRfZmllbGRzKSAqIFNJWkVPRl9TSE9SVDtcbiAgICAgICAgdGhpcy5hZGRJbnQxNihsZW4pO1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGFuIGV4aXN0aW5nIHZ0YWJsZSB0aGF0IG1hdGNoZXMgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgICBsZXQgZXhpc3RpbmdfdnRhYmxlID0gMDtcbiAgICAgICAgY29uc3QgdnQxID0gdGhpcy5zcGFjZTtcbiAgICAgICAgb3V0ZXJfbG9vcDogZm9yIChpID0gMDsgaSA8IHRoaXMudnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdnQyID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy52dGFibGVzW2ldO1xuICAgICAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmJiLnJlYWRJbnQxNih2dDIpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IFNJWkVPRl9TSE9SVDsgaiA8IGxlbjsgaiArPSBTSVpFT0ZfU0hPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmIucmVhZEludDE2KHZ0MSArIGopICE9IHRoaXMuYmIucmVhZEludDE2KHZ0MiArIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcl9sb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4aXN0aW5nX3Z0YWJsZSA9IHRoaXMudnRhYmxlc1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RpbmdfdnRhYmxlKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoOlxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgICAgICAgICAgIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2M7XG4gICAgICAgICAgICAvLyBQb2ludCB0YWJsZSB0byBleGlzdGluZyB2dGFibGUuXG4gICAgICAgICAgICB0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZSwgZXhpc3RpbmdfdnRhYmxlIC0gdnRhYmxlbG9jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIG1hdGNoOlxuICAgICAgICAgICAgLy8gQWRkIHRoZSBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCB2dGFibGUgdG8gdGhlIGxpc3Qgb2YgdnRhYmxlcy5cbiAgICAgICAgICAgIHRoaXMudnRhYmxlcy5wdXNoKHRoaXMub2Zmc2V0KCkpO1xuICAgICAgICAgICAgLy8gUG9pbnQgdGFibGUgdG8gY3VycmVudCB2dGFibGUuXG4gICAgICAgICAgICB0aGlzLmJiLndyaXRlSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdnRhYmxlbG9jLCB0aGlzLm9mZnNldCgpIC0gdnRhYmxlbG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB2dGFibGVsb2M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmFsaXplIGEgYnVmZmVyLCBwb2l0aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gICAgICovXG4gICAgZmluaXNoKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIG9wdF9zaXplX3ByZWZpeCkge1xuICAgICAgICBjb25zdCBzaXplX3ByZWZpeCA9IG9wdF9zaXplX3ByZWZpeCA/IFNJWkVfUFJFRklYX0xFTkdUSCA6IDA7XG4gICAgICAgIGlmIChvcHRfZmlsZV9pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlX2lkZW50aWZpZXIgPSBvcHRfZmlsZV9pZGVudGlmaWVyO1xuICAgICAgICAgICAgdGhpcy5wcmVwKHRoaXMubWluYWxpZ24sIFNJWkVPRl9JTlQgK1xuICAgICAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEggKyBzaXplX3ByZWZpeCk7XG4gICAgICAgICAgICBpZiAoZmlsZV9pZGVudGlmaWVyLmxlbmd0aCAhPSBGSUxFX0lERU5USUZJRVJfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgRklMRV9JREVOVElGSUVSX0xFTkdUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gRklMRV9JREVOVElGSUVSX0xFTkdUSCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUludDgoZmlsZV9pZGVudGlmaWVyLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLCBTSVpFT0ZfSU5UICsgc2l6ZV9wcmVmaXgpO1xuICAgICAgICB0aGlzLmFkZE9mZnNldChyb290X3RhYmxlKTtcbiAgICAgICAgaWYgKHNpemVfcHJlZml4KSB7XG4gICAgICAgICAgICB0aGlzLmFkZEludDMyKHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmFsaXplIGEgc2l6ZSBwcmVmaXhlZCBidWZmZXIsIHBvaW50aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gICAgICovXG4gICAgZmluaXNoU2l6ZVByZWZpeGVkKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIpIHtcbiAgICAgICAgdGhpcy5maW5pc2gocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgY2hlY2tzIGEgcmVxdWlyZWQgZmllbGQgaGFzIGJlZW4gc2V0IGluIGEgZ2l2ZW4gdGFibGUgdGhhdCBoYXNcbiAgICAgKiBqdXN0IGJlZW4gY29uc3RydWN0ZWQuXG4gICAgICovXG4gICAgcmVxdWlyZWRGaWVsZCh0YWJsZSwgZmllbGQpIHtcbiAgICAgICAgY29uc3QgdGFibGVfc3RhcnQgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0YWJsZTtcbiAgICAgICAgY29uc3QgdnRhYmxlX3N0YXJ0ID0gdGFibGVfc3RhcnQgLSB0aGlzLmJiLnJlYWRJbnQzMih0YWJsZV9zdGFydCk7XG4gICAgICAgIGNvbnN0IG9rID0gZmllbGQgPCB0aGlzLmJiLnJlYWRJbnQxNih2dGFibGVfc3RhcnQpICYmXG4gICAgICAgICAgICB0aGlzLmJiLnJlYWRJbnQxNih2dGFibGVfc3RhcnQgKyBmaWVsZCkgIT0gMDtcbiAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgdGhlIGNhbGxlciB3aWxsIHNob3cgd2hhdCBmaWVsZCBuZWVkcyB0byBiZSBzZXQuXG4gICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWVsZCAnICsgZmllbGQgKyAnIG11c3QgYmUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBuZXcgYXJyYXkvdmVjdG9yIG9mIG9iamVjdHMuICBVc2VycyB1c3VhbGx5IHdpbGwgbm90IGNhbGxcbiAgICAgKiB0aGlzIGRpcmVjdGx5LiBUaGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIgd2lsbCBjcmVhdGUgYSBzdGFydC9lbmRcbiAgICAgKiBtZXRob2QgZm9yIHZlY3RvciB0eXBlcyBpbiBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtX3NpemUgVGhlIHNpemUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqIEBwYXJhbSBudW1fZWxlbXMgVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gYWxpZ25tZW50IFRoZSBhbGlnbm1lbnQgb2YgdGhlIGFycmF5XG4gICAgICovXG4gICAgc3RhcnRWZWN0b3IoZWxlbV9zaXplLCBudW1fZWxlbXMsIGFsaWdubWVudCkge1xuICAgICAgICB0aGlzLm5vdE5lc3RlZCgpO1xuICAgICAgICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSBudW1fZWxlbXM7XG4gICAgICAgIHRoaXMucHJlcChTSVpFT0ZfSU5ULCBlbGVtX3NpemUgKiBudW1fZWxlbXMpO1xuICAgICAgICB0aGlzLnByZXAoYWxpZ25tZW50LCBlbGVtX3NpemUgKiBudW1fZWxlbXMpOyAvLyBKdXN0IGluIGNhc2UgYWxpZ25tZW50ID4gaW50LlxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggb2ZmIHRoZSBjcmVhdGlvbiBvZiBhbiBhcnJheSBhbmQgYWxsIGl0cyBlbGVtZW50cy4gVGhlIGFycmF5IG11c3QgYmVcbiAgICAgKiBjcmVhdGVkIHdpdGggYHN0YXJ0VmVjdG9yYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXlcbiAgICAgKiBzdGFydHMuXG4gICAgICovXG4gICAgZW5kVmVjdG9yKCkge1xuICAgICAgICB0aGlzLndyaXRlSW50MzIodGhpcy52ZWN0b3JfbnVtX2VsZW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgc3RyaW5nIGBzYCBpbiB0aGUgYnVmZmVyIHVzaW5nIFVURi04LiBJZiB0aGUgc3RyaW5nIHBhc3NlZCBoYXNcbiAgICAgKiBhbHJlYWR5IGJlZW4gc2Vlbiwgd2UgcmV0dXJuIHRoZSBvZmZzZXQgb2YgdGhlIGFscmVhZHkgd3JpdHRlbiBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzIFRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gICAgICogQHJldHVybiBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xuICAgICAqL1xuICAgIGNyZWF0ZVNoYXJlZFN0cmluZyhzKSB7XG4gICAgICAgIGlmICghcykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN0cmluZ19tYXBzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ19tYXBzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0cmluZ19tYXBzLmhhcyhzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nX21hcHMuZ2V0KHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY3JlYXRlU3RyaW5nKHMpO1xuICAgICAgICB0aGlzLnN0cmluZ19tYXBzLnNldChzLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdGhlIHN0cmluZyBgc2AgaW4gdGhlIGJ1ZmZlciB1c2luZyBVVEYtOC4gSWYgYSBVaW50OEFycmF5IGlzIHBhc3NlZFxuICAgICAqIGluc3RlYWQgb2YgYSBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gY29udGFpbiB2YWxpZCBVVEYtOCBlbmNvZGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICAgICAqIEByZXR1cm4gVGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHdoZXJlIHRoZSBlbmNvZGVkIHN0cmluZyBzdGFydHNcbiAgICAgKi9cbiAgICBjcmVhdGVTdHJpbmcocykge1xuICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1dGY4O1xuICAgICAgICBpZiAocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHV0ZjggPSBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRmOCA9IHRoaXMudGV4dF9lbmNvZGVyLmVuY29kZShzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEludDgoMCk7XG4gICAgICAgIHRoaXMuc3RhcnRWZWN0b3IoMSwgdXRmOC5sZW5ndGgsIDEpO1xuICAgICAgICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UgLT0gdXRmOC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlc1tvZmZzZXQrK10gPSB1dGY4W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBwYWNrIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybnMgb2Zmc2V0IG9mIG9ialxuICAgICAqL1xuICAgIGNyZWF0ZU9iamVjdE9mZnNldChvYmopIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmcob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoucGFjayh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBwYWNrIGEgbGlzdCBvZiBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGxpc3Qgb2Ygb2Zmc2V0cyBvZiBlYWNoIG5vbiBudWxsIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZU9iamVjdE9mZnNldExpc3QobGlzdCkge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHRoaXMuY3JlYXRlT2JqZWN0T2Zmc2V0KHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmxhdEJ1ZmZlcnM6IEFyZ3VtZW50IGZvciBjcmVhdGVPYmplY3RPZmZzZXRMaXN0IGNhbm5vdCBjb250YWluIG51bGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgY3JlYXRlU3RydWN0T2Zmc2V0TGlzdChsaXN0LCBzdGFydEZ1bmMpIHtcbiAgICAgICAgc3RhcnRGdW5jKHRoaXMsIGxpc3QubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVPYmplY3RPZmZzZXRMaXN0KGxpc3Quc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRWZWN0b3IoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBGSUxFX0lERU5USUZJRVJfTEVOR1RILCBTSVpFT0ZfSU5UIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBpbnQzMiwgaXNMaXR0bGVFbmRpYW4sIGZsb2F0MzIsIGZsb2F0NjQgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgRW5jb2RpbmcgfSBmcm9tIFwiLi9lbmNvZGluZy5qc1wiO1xuZXhwb3J0IGNsYXNzIEJ5dGVCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBhcnJheSBvZiBieXRlcyAoYFVpbnQ4QXJyYXlgKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzXykge1xuICAgICAgICB0aGlzLmJ5dGVzXyA9IGJ5dGVzXztcbiAgICAgICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xuICAgICAgICB0aGlzLnRleHRfZGVjb2Rlcl8gPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhbGxvY2F0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBzaXplLlxuICAgICAqL1xuICAgIHN0YXRpYyBhbGxvY2F0ZShieXRlX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ5dGVfc2l6ZSkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgYFVpbnQ4QXJyYXlgLlxuICAgICAqL1xuICAgIGJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc187XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gICAgICovXG4gICAgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uXyA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ1ZmZlcidzIGNhcGFjaXR5LlxuICAgICAqL1xuICAgIGNhcGFjaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc18ubGVuZ3RoO1xuICAgIH1cbiAgICByZWFkSW50OChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ4KG9mZnNldCkgPDwgMjQgPj4gMjQ7XG4gICAgfVxuICAgIHJlYWRVaW50OChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfW29mZnNldF07XG4gICAgfVxuICAgIHJlYWRJbnQxNihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQxNihvZmZzZXQpIDw8IDE2ID4+IDE2O1xuICAgIH1cbiAgICByZWFkVWludDE2KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDg7XG4gICAgfVxuICAgIHJlYWRJbnQzMihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfW29mZnNldF0gfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPDwgMTYgfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA8PCAyNDtcbiAgICB9XG4gICAgcmVhZFVpbnQzMihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCkgPj4+IDA7XG4gICAgfVxuICAgIHJlYWRJbnQ2NChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oNjQsIEJpZ0ludCh0aGlzLnJlYWRVaW50MzIob2Zmc2V0KSkgKyAoQmlnSW50KHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSkgPDwgQmlnSW50KDMyKSkpO1xuICAgIH1cbiAgICByZWFkVWludDY0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIEJpZ0ludCh0aGlzLnJlYWRVaW50MzIob2Zmc2V0KSkgKyAoQmlnSW50KHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSkgPDwgQmlnSW50KDMyKSkpO1xuICAgIH1cbiAgICByZWFkRmxvYXQzMihvZmZzZXQpIHtcbiAgICAgICAgaW50MzJbMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICAgICAgICByZXR1cm4gZmxvYXQzMlswXTtcbiAgICB9XG4gICAgcmVhZEZsb2F0NjQob2Zmc2V0KSB7XG4gICAgICAgIGludDMyW2lzTGl0dGxlRW5kaWFuID8gMCA6IDFdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgICAgICAgaW50MzJbaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIGZsb2F0NjRbMF07XG4gICAgfVxuICAgIHdyaXRlSW50OChvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgd3JpdGVVaW50OChvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgd3JpdGVJbnQxNihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgIH1cbiAgICB3cml0ZVVpbnQxNihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgIH1cbiAgICB3cml0ZUludDMyKG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XG4gICAgfVxuICAgIHdyaXRlVWludDMyKG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XG4gICAgfVxuICAgIHdyaXRlSW50NjQob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUpKSk7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUgPj4gQmlnSW50KDMyKSkpKTtcbiAgICB9XG4gICAgd3JpdGVVaW50NjQob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgTnVtYmVyKEJpZ0ludC5hc1VpbnROKDMyLCB2YWx1ZSkpKTtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQzMihvZmZzZXQgKyA0LCBOdW1iZXIoQmlnSW50LmFzVWludE4oMzIsIHZhbHVlID4+IEJpZ0ludCgzMikpKSk7XG4gICAgfVxuICAgIHdyaXRlRmxvYXQzMihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGZsb2F0MzJbMF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgaW50MzJbMF0pO1xuICAgIH1cbiAgICB3cml0ZUZsb2F0NjQob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBmbG9hdDY0WzBdID0gdmFsdWU7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIGludDMyW2lzTGl0dGxlRW5kaWFuID8gMCA6IDFdKTtcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCArIDQsIGludDMyW2lzTGl0dGxlRW5kaWFuID8gMSA6IDBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBmaWxlIGlkZW50aWZpZXIuICAgQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGZvciBGbGF0QnVmZmVycyB3aG9zZVxuICAgICAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXG4gICAgICogc3RhcnQgb2YgYSB0aGUgcm9vdCB2dGFibGUpLlxuICAgICAqL1xuICAgIGdldEJ1ZmZlcklkZW50aWZpZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ5dGVzXy5sZW5ndGggPCB0aGlzLnBvc2l0aW9uXyArIFNJWkVPRl9JTlQgK1xuICAgICAgICAgICAgRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXyArIFNJWkVPRl9JTlQgKyBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9vayB1cCBhIGZpZWxkIGluIHRoZSB2dGFibGUsIHJldHVybiBhbiBvZmZzZXQgaW50byB0aGUgb2JqZWN0LCBvciAwIGlmIHRoZVxuICAgICAqIGZpZWxkIGlzIG5vdCBwcmVzZW50LlxuICAgICAqL1xuICAgIF9fb2Zmc2V0KGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xuICAgICAgICBjb25zdCB2dGFibGUgPSBiYl9wb3MgLSB0aGlzLnJlYWRJbnQzMihiYl9wb3MpO1xuICAgICAgICByZXR1cm4gdnRhYmxlX29mZnNldCA8IHRoaXMucmVhZEludDE2KHZ0YWJsZSkgPyB0aGlzLnJlYWRJbnQxNih2dGFibGUgKyB2dGFibGVfb2Zmc2V0KSA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYW55IFRhYmxlLWRlcml2ZWQgdHlwZSB0byBwb2ludCB0byB0aGUgdW5pb24gYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgKi9cbiAgICBfX3VuaW9uKHQsIG9mZnNldCkge1xuICAgICAgICB0LmJiX3BvcyA9IG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gICAgICAgIHQuYmIgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgSmF2YVNjcmlwdCBzdHJpbmcgZnJvbSBVVEYtOCBkYXRhIHN0b3JlZCBpbnNpZGUgdGhlIEZsYXRCdWZmZXIuXG4gICAgICogVGhpcyBhbGxvY2F0ZXMgYSBuZXcgc3RyaW5nIGFuZCBjb252ZXJ0cyB0byB3aWRlIGNoYXJzIHVwb24gZWFjaCBhY2Nlc3MuXG4gICAgICpcbiAgICAgKiBUbyBhdm9pZCB0aGUgY29udmVyc2lvbiB0byBzdHJpbmcsIHBhc3MgRW5jb2RpbmcuVVRGOF9CWVRFUyBhcyB0aGVcbiAgICAgKiBcIm9wdGlvbmFsRW5jb2RpbmdcIiBhcmd1bWVudC4gVGhpcyBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nIGNvbnZlcnNpb24gd2hlblxuICAgICAqIHRoZSBkYXRhIHdpbGwganVzdCBiZSBwYWNrYWdlZCBiYWNrIHVwIGluIGFub3RoZXIgRmxhdEJ1ZmZlciBsYXRlciBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcGFyYW0gb3B0X2VuY29kaW5nIERlZmF1bHRzIHRvIFVURjE2X1NUUklOR1xuICAgICAqL1xuICAgIF9fc3RyaW5nKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gU0laRU9GX0lOVDtcbiAgICAgICAgY29uc3QgdXRmOGJ5dGVzID0gdGhpcy5ieXRlc18uc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICBpZiAob3B0X2VuY29kaW5nID09PSBFbmNvZGluZy5VVEY4X0JZVEVTKVxuICAgICAgICAgICAgcmV0dXJuIHV0ZjhieXRlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dF9kZWNvZGVyXy5kZWNvZGUodXRmOGJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHVuaW9ucyB0aGF0IGNhbiBjb250YWluIHN0cmluZyBhcyBpdHMgbWVtYmVyLCBpZiBhIFRhYmxlLWRlcml2ZWQgdHlwZSB0aGVuIGluaXRpYWxpemUgaXQsXG4gICAgICogaWYgYSBzdHJpbmcgdGhlbiByZXR1cm4gYSBuZXcgb25lXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBzdHJpbmdzIGFyZSBpbW11dGFibGUgaW4gSlMgc28gd2UgY2FuJ3QgY2hhbmdlIHRoZSBzdHJpbmcgdGhhdCB0aGUgdXNlciBnYXZlIHVzLCB0aGlzXG4gICAgICogbWFrZXMgdGhlIGJlaGF2aW91ciBvZiBfX3VuaW9uX3dpdGhfc3RyaW5nIGRpZmZlcmVudCBjb21wYXJlZCB0byBfX3VuaW9uXG4gICAgICovXG4gICAgX191bmlvbl93aXRoX3N0cmluZyhvLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19zdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX3VuaW9uKG8sIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSByZWxhdGl2ZSBvZmZzZXQgc3RvcmVkIGF0IFwib2Zmc2V0XCJcbiAgICAgKi9cbiAgICBfX2luZGlyZWN0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGFydCBvZiBkYXRhIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBfX3ZlY3RvcihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCkgKyBTSVpFT0ZfSU5UOyAvLyBkYXRhIHN0YXJ0cyBhZnRlciB0aGUgbGVuZ3RoXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBfX3ZlY3Rvcl9sZW4ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpKTtcbiAgICB9XG4gICAgX19oYXNfaWRlbnRpZmllcihpZGVudCkge1xuICAgICAgICBpZiAoaWRlbnQubGVuZ3RoICE9IEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcbiAgICAgICAgICAgICAgICBGSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlkZW50LmNoYXJDb2RlQXQoaSkgIT0gdGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uKCkgKyBTSVpFT0ZfSU5UICsgaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGxpc3QgZm9yIG9iaiBhcGlcbiAgICAgKi9cbiAgICBjcmVhdGVTY2FsYXJMaXN0KGxpc3RBY2Nlc3NvciwgbGlzdExlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGxpc3RBY2Nlc3NvcihpKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGxpc3QgZm9yIG9iaiBhcGlcbiAgICAgKiBAcGFyYW0gbGlzdEFjY2Vzc29yIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBpbmRleCBhbmQgcmV0dXJuIGRhdGEgYXQgdGhhdCBpbmRleFxuICAgICAqIEBwYXJhbSBsaXN0TGVuZ3RoIGxpc3RMZW5ndGhcbiAgICAgKiBAcGFyYW0gcmVzIHJlc3VsdCBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlT2JqTGlzdChsaXN0QWNjZXNzb3IsIGxpc3RMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0QWNjZXNzb3IoaSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2godmFsLnVucGFjaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbiIsImV4cG9ydCBjb25zdCBTSVpFT0ZfU0hPUlQgPSAyO1xuZXhwb3J0IGNvbnN0IFNJWkVPRl9JTlQgPSA0O1xuZXhwb3J0IGNvbnN0IEZJTEVfSURFTlRJRklFUl9MRU5HVEggPSA0O1xuZXhwb3J0IGNvbnN0IFNJWkVfUFJFRklYX0xFTkdUSCA9IDQ7XG4iLCJleHBvcnQgdmFyIEVuY29kaW5nO1xuKGZ1bmN0aW9uIChFbmNvZGluZykge1xuICAgIEVuY29kaW5nW0VuY29kaW5nW1wiVVRGOF9CWVRFU1wiXSA9IDFdID0gXCJVVEY4X0JZVEVTXCI7XG4gICAgRW5jb2RpbmdbRW5jb2RpbmdbXCJVVEYxNl9TVFJJTkdcIl0gPSAyXSA9IFwiVVRGMTZfU1RSSU5HXCI7XG59KShFbmNvZGluZyB8fCAoRW5jb2RpbmcgPSB7fSkpO1xuIiwiZXhwb3J0IHsgU0laRU9GX1NIT1JUIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuZXhwb3J0IHsgU0laRU9GX0lOVCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmV4cG9ydCB7IEZJTEVfSURFTlRJRklFUl9MRU5HVEggfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5leHBvcnQgeyBTSVpFX1BSRUZJWF9MRU5HVEggfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5leHBvcnQgeyBpbnQzMiwgZmxvYXQzMiwgZmxvYXQ2NCwgaXNMaXR0bGVFbmRpYW4gfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCB7IEVuY29kaW5nIH0gZnJvbSAnLi9lbmNvZGluZy5qcyc7XG5leHBvcnQgeyBCdWlsZGVyIH0gZnJvbSAnLi9idWlsZGVyLmpzJztcbmV4cG9ydCB7IEJ5dGVCdWZmZXIgfSBmcm9tICcuL2J5dGUtYnVmZmVyLmpzJztcbiIsImV4cG9ydCBjb25zdCBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xuZXhwb3J0IGNvbnN0IGZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KGludDMyLmJ1ZmZlcik7XG5leHBvcnQgY29uc3QgZmxvYXQ2NCA9IG5ldyBGbG9hdDY0QXJyYXkoaW50MzIuYnVmZmVyKTtcbmV4cG9ydCBjb25zdCBpc0xpdHRsZUVuZGlhbiA9IG5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwgMF0pLmJ1ZmZlcilbMF0gPT09IDE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaFdlYXRoZXJBcGkgPSB2b2lkIDA7XG5jb25zdCBmbGF0YnVmZmVyc18xID0gcmVxdWlyZShcImZsYXRidWZmZXJzXCIpO1xuY29uc3Qgd2VhdGhlcl9hcGlfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCJAb3Blbm1ldGVvL3Nkay93ZWF0aGVyLWFwaS1yZXNwb25zZVwiKTtcbmNvbnN0IHNsZWVwID0gKG1zKSA9PiBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgbXMpKTtcbmZ1bmN0aW9uIGZldGNoUmV0cmllZCh1cmwsIHJldHJpZXMgPSAzLCBiYWNrb2ZmRmFjdG9yID0gMC41LCBiYWNrb2ZmTWF4ID0gMikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1c1RvUmV0cnkgPSBbNTAwLCA1MDIsIDUwNF07XG4gICAgICAgIGNvbnN0IHN0YXR1c1dpdGhKc29uRXJyb3IgPSBbNDAwLCA0MjldO1xuICAgICAgICBsZXQgY3VycmVudFRyeSA9IDA7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHVybCk7XG4gICAgICAgIHdoaWxlIChzdGF0dXNUb1JldHJ5LmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUcnkrKztcbiAgICAgICAgICAgIGlmIChjdXJyZW50VHJ5ID49IHJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzbGVlcE1zID0gTWF0aC5taW4oYmFja29mZkZhY3RvciAqIE1hdGgucG93KDIsIGN1cnJlbnRUcnkpLCBiYWNrb2ZmTWF4KSAqIDEwMDA7XG4gICAgICAgICAgICB5aWVsZCBzbGVlcChzbGVlcE1zKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzV2l0aEpzb25FcnJvci5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCdyZWFzb24nIGluIGpzb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoanNvbi5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0cmlldmUgZGF0YSBmcm9tIHRoZSBPcGVuLU1ldGVvIHdlYXRoZXIgQVBJXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBTZXJ2ZXIgYW5kIGVuZHBvaW50LiBFLmcuIFwiaHR0cHM6Ly9hcGkub3Blbi1tZXRlby5jb20vdjEvZm9yZWNhc3RcIlxuICogQHBhcmFtIHthbnl9IHBhcmFtcyBVUkwgcGFyYW1ldGVyIGFzIGFuIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXJ9IFtyZXRyaWVzPTNdIE51bWJlciBvZiByZXRyaWVzIGluIGNhc2Ugb2YgYW4gc2VydmVyIGVycm9yXG4gKiBAcGFyYW0ge251bWJlcn0gW2JhY2tvZmZGYWN0b3I9MC4yXSBFeHBvbmVudGlhbCBiYWNrb2ZmIGZhY3RvciB0byBpbmNyZWFzZSB3YWl0IHRpbWUgYWZ0ZXIgZWFjaCByZXRyeVxuICogQHBhcmFtIHtudW1iZXJ9IFtiYWNrb2ZmTWF4PTJdIE1heGltdW0gd2FpdCB0aW1lIGJldHdlZW4gcmV0cmllc1xuICogQHJldHVybnMge1Byb21pc2U8V2VhdGhlckFwaVJlc3BvbnNlW10+fVxuICovXG5mdW5jdGlvbiBmZXRjaFdlYXRoZXJBcGkodXJsLCBwYXJhbXMsIHJldHJpZXMgPSAzLCBiYWNrb2ZmRmFjdG9yID0gMC4yLCBiYWNrb2ZmTWF4ID0gMikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgdXJsUGFyYW1zLnNldCgnZm9ybWF0JywgJ2ZsYXRidWZmZXJzJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2hSZXRyaWVkKGAke3VybH0/JHt1cmxQYXJhbXMudG9TdHJpbmcoKX1gLCByZXRyaWVzLCBiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmTWF4KTtcbiAgICAgICAgY29uc3QgZmIgPSBuZXcgZmxhdGJ1ZmZlcnNfMS5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KHlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IGZiLmNhcGFjaXR5KCkpIHtcbiAgICAgICAgICAgIGZiLnNldFBvc2l0aW9uKHBvcyk7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBmYi5yZWFkSW50MzIoZmIucG9zaXRpb24oKSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2god2VhdGhlcl9hcGlfcmVzcG9uc2VfMS5XZWF0aGVyQXBpUmVzcG9uc2UuZ2V0U2l6ZVByZWZpeGVkUm9vdEFzV2VhdGhlckFwaVJlc3BvbnNlKGZiKSk7XG4gICAgICAgICAgICBwb3MgKz0gbGVuICsgNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hXZWF0aGVyQXBpID0gZmV0Y2hXZWF0aGVyQXBpO1xuIiwiY29uc3QgY3R4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGFydFwiKTtcbmxldCBjO1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JhcGhlcihsYXRpdHVkZSwgbG9uZ2l0dWRlLCBkYXksIGRheV9uaWdodCkge1xuXHRjb25zdCB0ZW1wcyA9IGF3YWl0IGdldERhaWx5KGxhdGl0dWRlLCBsb25naXR1ZGUpO1xuXHRjb25zdCBkYXlUZW1wID0gdGVtcHNbZGF5XTtcbiAgbGV0IGNvbG9yID0gZGF5X25pZ2h0ID09IDAgPyBcInJnYigyNTAsIDE1OCwgNjYpXCIgOiAncmdiKDExMyw2MywyNTMpJztcblxuXHRjID0gbmV3IENoYXJ0KGN0eCwge1xuXHQgIHR5cGU6IFwibGluZVwiLFxuXHQgIGRhdGE6IHtcblx0XHRsYWJlbHM6IFtcblx0XHQgIFwiMTJBTVwiLFxuXHRcdCAgXCIxQU1cIixcblx0XHQgIFwiMkFNXCIsXG5cdFx0ICBcIjNBTVwiLFxuXHRcdCAgXCI0QU1cIixcblx0XHQgIFwiNUFNXCIsXG5cdFx0ICBcIjZBTVwiLFxuXHRcdCAgXCI3QU1cIixcblx0XHQgIFwiOEFNXCIsXG5cdFx0ICBcIjlBTVwiLFxuXHRcdCAgXCIxMEFNXCIsXG5cdFx0ICBcIjExQU1cIixcblx0XHQgIFwiMTJQTVwiLFxuXHRcdCAgXCIxUE1cIixcblx0XHQgIFwiMlBNXCIsXG5cdFx0ICBcIjNQTVwiLFxuXHRcdCAgXCI0UE1cIixcblx0XHQgIFwiNVBNXCIsXG5cdFx0ICBcIjZQTVwiLFxuXHRcdCAgXCI3UE1cIixcblx0XHQgIFwiOFBNXCIsXG5cdFx0ICBcIjlQTVwiLFxuXHRcdCAgXCIxMFBNXCIsXG5cdFx0ICBcIjExUE1cIixcblx0XHRdLFxuXHRcdGRhdGFzZXRzOiBbXG5cdFx0ICB7XG5cdFx0XHRsYWJlbDogXCJUZW1wIGluIEPCsFwiLFxuXHRcdFx0ZGF0YTogZGF5VGVtcCxcbiAgICAgIGJvcmRlckNvbG9yOiBjb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdCAgfSxcblx0XHRdLFxuXHQgIH0sXG5cdCAgb3B0aW9uczoge1xuXHRcdHNjYWxlczoge1xuXHRcdCAgeToge1xuXHRcdFx0YmVnaW5BdFplcm86IHRydWUsXG5cdFx0ICB9LFxuXHRcdH0sXG5cdCAgfSxcblx0fSk7XG5cblxuICB9XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95KCkge1xuICBjLmRlc3Ryb3koKVxufVxuICBcblxuYXN5bmMgZnVuY3Rpb24gZ2V0RGFpbHkobGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICB0cnkge1xuXHRsZXQgZGF5cyA9IFtdO1xuICAgIGNvbnN0IGZldGNoV2VhdGhlckFwaSA9IHJlcXVpcmUoXCJvcGVubWV0ZW9cIikuZmV0Y2hXZWF0aGVyQXBpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgaG91cmx5OiBcInRlbXBlcmF0dXJlXzJtXCIsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBcImh0dHBzOi8vYXBpLm9wZW4tbWV0ZW8uY29tL3YxL2ZvcmVjYXN0XCI7XG5cbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBmZXRjaFdlYXRoZXJBcGkodXJsLCBwYXJhbXMpO1xuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZvcm0gdGltZSByYW5nZXNcbiAgICBjb25zdCByYW5nZSA9IChzdGFydCwgc3RvcCwgc3RlcCkgPT5cbiAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IChzdG9wIC0gc3RhcnQpIC8gc3RlcCB9LCAoXywgaSkgPT4gc3RhcnQgKyBpICogc3RlcCk7XG4gICAgLy8gUHJvY2VzcyBmaXJzdCBsb2NhdGlvbi4gQWRkIGEgZm9yLWxvb3AgZm9yIG11bHRpcGxlIGxvY2F0aW9ucyBvciB3ZWF0aGVyIG1vZGVsc1xuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VzWzBdO1xuICAgIC8vIEF0dHJpYnV0ZXMgZm9yIHRpbWV6b25lIGFuZCBsb2NhdGlvblxuICAgIGNvbnN0IHV0Y09mZnNldFNlY29uZHMgPSByZXNwb25zZS51dGNPZmZzZXRTZWNvbmRzKCk7XG4gICAgY29uc3QgdGltZXpvbmUgPSByZXNwb25zZS50aW1lem9uZSgpO1xuICAgIGNvbnN0IHRpbWV6b25lQWJicmV2aWF0aW9uID0gcmVzcG9uc2UudGltZXpvbmVBYmJyZXZpYXRpb24oKTtcbiAgICAvL2NvbnN0IGxhdGl0dWRlID0gcmVzcG9uc2UubGF0aXR1ZGUoKTtcbiAgICAvL2NvbnN0IGxvbmdpdHVkZSA9IHJlc3BvbnNlLmxvbmdpdHVkZSgpO1xuICAgIGNvbnN0IGhvdXJseSA9IHJlc3BvbnNlLmhvdXJseSgpO1xuICAgIC8vIE5vdGU6IFRoZSBvcmRlciBvZiB3ZWF0aGVyIHZhcmlhYmxlcyBpbiB0aGUgVVJMIHF1ZXJ5IGFuZCB0aGUgaW5kaWNlcyBiZWxvdyBuZWVkIHRvIG1hdGNoIVxuICAgIGNvbnN0IHdlYXRoZXJEYXRhID0ge1xuICAgICAgaG91cmx5OiB7XG4gICAgICAgIHRpbWU6IHJhbmdlKFxuICAgICAgICAgIE51bWJlcihob3VybHkudGltZSgpKSxcbiAgICAgICAgICBOdW1iZXIoaG91cmx5LnRpbWVFbmQoKSksXG4gICAgICAgICAgaG91cmx5LmludGVydmFsKClcbiAgICAgICAgKS5tYXAoKHQpID0+IG5ldyBEYXRlKCh0ICsgdXRjT2Zmc2V0U2Vjb25kcykgKiAxMDAwKSksXG4gICAgICAgIHRlbXBlcmF0dXJlMm06IGhvdXJseS52YXJpYWJsZXMoMCkudmFsdWVzQXJyYXkoKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICAvLyBgd2VhdGhlckRhdGFgIG5vdyBjb250YWlucyBhIHNpbXBsZSBzdHJ1Y3R1cmUgd2l0aCBhcnJheXMgZm9yIGRhdGV0aW1lIGFuZCB3ZWF0aGVyIGRhdGFcblxuICAgIGxldCBkYXkgPSBbXTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBkYXlubyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWF0aGVyRGF0YS5ob3VybHkudGltZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRheW5vID49IDMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPCAyNCkge1xuICAgICAgICBkYXkucHVzaCh3ZWF0aGVyRGF0YS5ob3VybHkudGVtcGVyYXR1cmUybVtpXS50b0ZpeGVkKDIpKTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgZGF5bm8rKztcbiAgICAgICAgLy9kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgZGF5cy5wdXNoKGRheSk7XG4gICAgICAgIGRheSA9IFtdO1xuICAgICAgICBkYXkucHVzaCh3ZWF0aGVyRGF0YS5ob3VybHkudGVtcGVyYXR1cmUybVtpXS50b0ZpeGVkKDIpKTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF5cztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBkdXJpbmcgaG91ciBmZXRjaFwiLCBlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9